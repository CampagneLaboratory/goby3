// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Alignments.proto

package edu.cornell.med.icb.goby.alignments;

public final class Alignments {
  private Alignments() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  public interface AlignmentCollectionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.AlignmentCollection)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry> 
        getAlignmentEntriesList();
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry getAlignmentEntries(int index);
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    int getAlignmentEntriesCount();
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder> 
        getAlignmentEntriesOrBuilderList();
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder getAlignmentEntriesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code goby.AlignmentCollection}
   *
   * <pre>
   *This message is written to 'basename'.entries as a very large chunked collection.
   * </pre>
   */
  public static final class AlignmentCollection extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.AlignmentCollection)
      AlignmentCollectionOrBuilder {
    // Use AlignmentCollection.newBuilder() to construct.
    private AlignmentCollection(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private AlignmentCollection(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final AlignmentCollection defaultInstance;
    public static AlignmentCollection getDefaultInstance() {
      return defaultInstance;
    }

    public AlignmentCollection getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private AlignmentCollection(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                alignmentEntries_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry>();
                mutable_bitField0_ |= 0x00000001;
              }
              alignmentEntries_.add(input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.PARSER, extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          alignmentEntries_ = java.util.Collections.unmodifiableList(alignmentEntries_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentCollection_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentCollection_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection.Builder.class);
    }

    public static com.google.protobuf.Parser<AlignmentCollection> PARSER =
        new com.google.protobuf.AbstractParser<AlignmentCollection>() {
      public AlignmentCollection parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AlignmentCollection(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<AlignmentCollection> getParserForType() {
      return PARSER;
    }

    public static final int ALIGNMENT_ENTRIES_FIELD_NUMBER = 1;
    private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry> alignmentEntries_;
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry> getAlignmentEntriesList() {
      return alignmentEntries_;
    }
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder> 
        getAlignmentEntriesOrBuilderList() {
      return alignmentEntries_;
    }
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    public int getAlignmentEntriesCount() {
      return alignmentEntries_.size();
    }
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry getAlignmentEntries(int index) {
      return alignmentEntries_.get(index);
    }
    /**
     * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder getAlignmentEntriesOrBuilder(
        int index) {
      return alignmentEntries_.get(index);
    }

    private void initFields() {
      alignmentEntries_ = java.util.Collections.emptyList();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      for (int i = 0; i < alignmentEntries_.size(); i++) {
        output.writeMessage(1, alignmentEntries_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < alignmentEntries_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, alignmentEntries_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.AlignmentCollection}
     *
     * <pre>
     *This message is written to 'basename'.entries as a very large chunked collection.
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.AlignmentCollection)
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollectionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentCollection_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentCollection_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getAlignmentEntriesFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        if (alignmentEntriesBuilder_ == null) {
          alignmentEntries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          alignmentEntriesBuilder_.clear();
        }
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentCollection_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection build() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection result = new edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection(this);
        int from_bitField0_ = bitField0_;
        if (alignmentEntriesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            alignmentEntries_ = java.util.Collections.unmodifiableList(alignmentEntries_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.alignmentEntries_ = alignmentEntries_;
        } else {
          result.alignmentEntries_ = alignmentEntriesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection.getDefaultInstance()) return this;
        if (alignmentEntriesBuilder_ == null) {
          if (!other.alignmentEntries_.isEmpty()) {
            if (alignmentEntries_.isEmpty()) {
              alignmentEntries_ = other.alignmentEntries_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureAlignmentEntriesIsMutable();
              alignmentEntries_.addAll(other.alignmentEntries_);
            }
            onChanged();
          }
        } else {
          if (!other.alignmentEntries_.isEmpty()) {
            if (alignmentEntriesBuilder_.isEmpty()) {
              alignmentEntriesBuilder_.dispose();
              alignmentEntriesBuilder_ = null;
              alignmentEntries_ = other.alignmentEntries_;
              bitField0_ = (bitField0_ & ~0x00000001);
              alignmentEntriesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getAlignmentEntriesFieldBuilder() : null;
            } else {
              alignmentEntriesBuilder_.addAllMessages(other.alignmentEntries_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.AlignmentCollection) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry> alignmentEntries_ =
        java.util.Collections.emptyList();
      private void ensureAlignmentEntriesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          alignmentEntries_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry>(alignmentEntries_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder> alignmentEntriesBuilder_;

      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry> getAlignmentEntriesList() {
        if (alignmentEntriesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(alignmentEntries_);
        } else {
          return alignmentEntriesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public int getAlignmentEntriesCount() {
        if (alignmentEntriesBuilder_ == null) {
          return alignmentEntries_.size();
        } else {
          return alignmentEntriesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry getAlignmentEntries(int index) {
        if (alignmentEntriesBuilder_ == null) {
          return alignmentEntries_.get(index);
        } else {
          return alignmentEntriesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder setAlignmentEntries(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry value) {
        if (alignmentEntriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAlignmentEntriesIsMutable();
          alignmentEntries_.set(index, value);
          onChanged();
        } else {
          alignmentEntriesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder setAlignmentEntries(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder builderForValue) {
        if (alignmentEntriesBuilder_ == null) {
          ensureAlignmentEntriesIsMutable();
          alignmentEntries_.set(index, builderForValue.build());
          onChanged();
        } else {
          alignmentEntriesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder addAlignmentEntries(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry value) {
        if (alignmentEntriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAlignmentEntriesIsMutable();
          alignmentEntries_.add(value);
          onChanged();
        } else {
          alignmentEntriesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder addAlignmentEntries(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry value) {
        if (alignmentEntriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAlignmentEntriesIsMutable();
          alignmentEntries_.add(index, value);
          onChanged();
        } else {
          alignmentEntriesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder addAlignmentEntries(
          edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder builderForValue) {
        if (alignmentEntriesBuilder_ == null) {
          ensureAlignmentEntriesIsMutable();
          alignmentEntries_.add(builderForValue.build());
          onChanged();
        } else {
          alignmentEntriesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder addAlignmentEntries(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder builderForValue) {
        if (alignmentEntriesBuilder_ == null) {
          ensureAlignmentEntriesIsMutable();
          alignmentEntries_.add(index, builderForValue.build());
          onChanged();
        } else {
          alignmentEntriesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder addAllAlignmentEntries(
          java.lang.Iterable<? extends edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry> values) {
        if (alignmentEntriesBuilder_ == null) {
          ensureAlignmentEntriesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, alignmentEntries_);
          onChanged();
        } else {
          alignmentEntriesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder clearAlignmentEntries() {
        if (alignmentEntriesBuilder_ == null) {
          alignmentEntries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          alignmentEntriesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public Builder removeAlignmentEntries(int index) {
        if (alignmentEntriesBuilder_ == null) {
          ensureAlignmentEntriesIsMutable();
          alignmentEntries_.remove(index);
          onChanged();
        } else {
          alignmentEntriesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder getAlignmentEntriesBuilder(
          int index) {
        return getAlignmentEntriesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder getAlignmentEntriesOrBuilder(
          int index) {
        if (alignmentEntriesBuilder_ == null) {
          return alignmentEntries_.get(index);  } else {
          return alignmentEntriesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder> 
           getAlignmentEntriesOrBuilderList() {
        if (alignmentEntriesBuilder_ != null) {
          return alignmentEntriesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(alignmentEntries_);
        }
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder addAlignmentEntriesBuilder() {
        return getAlignmentEntriesFieldBuilder().addBuilder(
            edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder addAlignmentEntriesBuilder(
          int index) {
        return getAlignmentEntriesFieldBuilder().addBuilder(
            index, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.AlignmentEntry alignment_entries = 1;</code>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder> 
           getAlignmentEntriesBuilderList() {
        return getAlignmentEntriesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder> 
          getAlignmentEntriesFieldBuilder() {
        if (alignmentEntriesBuilder_ == null) {
          alignmentEntriesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder>(
                  alignmentEntries_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          alignmentEntries_ = null;
        }
        return alignmentEntriesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:goby.AlignmentCollection)
    }

    static {
      defaultInstance = new AlignmentCollection(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.AlignmentCollection)
  }

  public interface AlignmentEntryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.AlignmentEntry)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint32 multiplicity = 7;</code>
     *
     * <pre>
     * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
     *query redundancy had not been removed by read factorization.
     * </pre>
     */
    boolean hasMultiplicity();
    /**
     * <code>optional uint32 multiplicity = 7;</code>
     *
     * <pre>
     * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
     *query redundancy had not been removed by read factorization.
     * </pre>
     */
    int getMultiplicity();

    /**
     * <code>optional uint32 query_index = 1;</code>
     *
     * <pre>
     * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
     *alignment runs are made with the same set of query sequences, equality of query index means that the query
     *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasQueryIndex();
    /**
     * <code>optional uint32 query_index = 1;</code>
     *
     * <pre>
     * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
     *alignment runs are made with the same set of query sequences, equality of query index means that the query
     *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getQueryIndex();

    /**
     * <code>optional uint32 target_index = 2;</code>
     *
     * <pre>
     * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
     *alignment runs are made with the same set of target sequences, equality of target index means that the target
     *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasTargetIndex();
    /**
     * <code>optional uint32 target_index = 2;</code>
     *
     * <pre>
     * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
     *alignment runs are made with the same set of target sequences, equality of target index means that the target
     *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getTargetIndex();

    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position on the target of the start of the alignment between the query and the target.
     *In the following example, position is 3 because the third base of the query 'C' was aligned with
     *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
     *alignment can start at a mismatch if it was so constructed by the aligner.
     *0123456789
     *AAAAGTCAAA  target
     *ctCGTC     query
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasPosition();
    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position on the target of the start of the alignment between the query and the target.
     *In the following example, position is 3 because the third base of the query 'C' was aligned with
     *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
     *alignment can start at a mismatch if it was so constructed by the aligner.
     *0123456789
     *AAAAGTCAAA  target
     *ctCGTC     query
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getPosition();

    /**
     * <code>optional bool matching_reverse_strand = 6;</code>
     *
     * <pre>
     *True when the query matches the target on the reverse strand
     * </pre>
     */
    boolean hasMatchingReverseStrand();
    /**
     * <code>optional bool matching_reverse_strand = 6;</code>
     *
     * <pre>
     *True when the query matches the target on the reverse strand
     * </pre>
     */
    boolean getMatchingReverseStrand();

    /**
     * <code>optional uint32 query_position = 5;</code>
     *
     * <pre>
     *The position on the query where the alignment starts. This value is different from zero
     *when some bases/residues of the query could not be aligned with the target.
     *TODO: Rename this to left_trim. Add a right_trim property.
     * </pre>
     */
    boolean hasQueryPosition();
    /**
     * <code>optional uint32 query_position = 5;</code>
     *
     * <pre>
     *The position on the query where the alignment starts. This value is different from zero
     *when some bases/residues of the query could not be aligned with the target.
     *TODO: Rename this to left_trim. Add a right_trim property.
     * </pre>
     */
    int getQueryPosition();

    /**
     * <code>optional float score = 4;</code>
     *
     * <pre>
     *The score of the alignment, where larger scores indicate better matches between the query and the target.
     *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
     *-(#mismatches(query,target)).
     * </pre>
     */
    boolean hasScore();
    /**
     * <code>optional float score = 4;</code>
     *
     * <pre>
     *The score of the alignment, where larger scores indicate better matches between the query and the target.
     *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
     *-(#mismatches(query,target)).
     * </pre>
     */
    float getScore();

    /**
     * <code>optional uint32 number_of_mismatches = 8;</code>
     *
     * <pre>
     *Number of bases/residues that differ in the alignment between query and target sequences.
     * </pre>
     */
    boolean hasNumberOfMismatches();
    /**
     * <code>optional uint32 number_of_mismatches = 8;</code>
     *
     * <pre>
     *Number of bases/residues that differ in the alignment between query and target sequences.
     * </pre>
     */
    int getNumberOfMismatches();

    /**
     * <code>optional uint32 number_of_indels = 9;</code>
     *
     * <pre>
     *Cumulative number of insertions and/or deletions present in the alignment.
     * </pre>
     */
    boolean hasNumberOfIndels();
    /**
     * <code>optional uint32 number_of_indels = 9;</code>
     *
     * <pre>
     *Cumulative number of insertions and/or deletions present in the alignment.
     * </pre>
     */
    int getNumberOfIndels();

    /**
     * <code>optional uint32 query_aligned_length = 11;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
     *less or equal to query_length.
     * </pre>
     */
    boolean hasQueryAlignedLength();
    /**
     * <code>optional uint32 query_aligned_length = 11;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
     *less or equal to query_length.
     * </pre>
     */
    int getQueryAlignedLength();

    /**
     * <code>optional uint32 target_aligned_length = 12;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the target.
     * </pre>
     */
    boolean hasTargetAlignedLength();
    /**
     * <code>optional uint32 target_aligned_length = 12;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the target.
     * </pre>
     */
    int getTargetAlignedLength();

    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation> 
        getSequenceVariationsList();
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation getSequenceVariations(int index);
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    int getSequenceVariationsCount();
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder> 
        getSequenceVariationsOrBuilderList();
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder getSequenceVariationsOrBuilder(
        int index);

    /**
     * <code>optional uint32 query_length = 10;</code>
     *
     * <pre>
     *Length of the query sequence.
     * </pre>
     */
    boolean hasQueryLength();
    /**
     * <code>optional uint32 query_length = 10;</code>
     *
     * <pre>
     *Length of the query sequence.
     * </pre>
     */
    int getQueryLength();

    /**
     * <code>optional int32 mapping_quality = 14;</code>
     *
     * <pre>
     *Mapping Quality (phred-scaled posterior probability that the mapping
     *position of this read is incorrect). Please note that different aligners
     *may estimate mapping quality with different approaches, resulting in aligner
     *specific differences in the distribution of mapping quality. It is recommended
     *to condition mapping quality on the aligner that produced the specific alignment
     *being processed. See aligner name and version in the header.
     *Note that the following description is preliminary. A clear specification is
     *needed:
     *The mapping quality should be proportional to the
     *log of the probability that the given mapping is the "correct" one.
     *So if there are five equally good mappings of a read to the genome,
     *the probability of each would be 0.2, and the mapping quality would be
     *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
     *say a 1e-4 of it being wrong, then the mapping quality would be
     *-10*log10(1e-4) = 40.
     * </pre>
     */
    boolean hasMappingQuality();
    /**
     * <code>optional int32 mapping_quality = 14;</code>
     *
     * <pre>
     *Mapping Quality (phred-scaled posterior probability that the mapping
     *position of this read is incorrect). Please note that different aligners
     *may estimate mapping quality with different approaches, resulting in aligner
     *specific differences in the distribution of mapping quality. It is recommended
     *to condition mapping quality on the aligner that produced the specific alignment
     *being processed. See aligner name and version in the header.
     *Note that the following description is preliminary. A clear specification is
     *needed:
     *The mapping quality should be proportional to the
     *log of the probability that the given mapping is the "correct" one.
     *So if there are five equally good mappings of a read to the genome,
     *the probability of each would be 0.2, and the mapping quality would be
     *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
     *say a 1e-4 of it being wrong, then the mapping quality would be
     *-10*log10(1e-4) = 40.
     * </pre>
     */
    int getMappingQuality();

    /**
     * <code>optional uint32 pair_flags = 15;</code>
     *
     * <pre>
     *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
     *000000001    paired
     *000000010    properly paired
     *000000100    read unmapped
     *000001000    mate unmapped
     *000010000    read reverse strand
     *000100000    mate reverse strand
     *001000000    first in pair
     *010000000    second in pair
     *100000000    not primary alignment
     * </pre>
     */
    boolean hasPairFlags();
    /**
     * <code>optional uint32 pair_flags = 15;</code>
     *
     * <pre>
     *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
     *000000001    paired
     *000000010    properly paired
     *000000100    read unmapped
     *000001000    mate unmapped
     *000010000    read reverse strand
     *000100000    mate reverse strand
     *001000000    first in pair
     *010000000    second in pair
     *100000000    not primary alignment
     * </pre>
     */
    int getPairFlags();

    /**
     * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
     *
     * <pre>
     *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
     * </pre>
     */
    boolean hasPairAlignmentLink();
    /**
     * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
     *
     * <pre>
     *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getPairAlignmentLink();
    /**
     * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
     *
     * <pre>
     *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getPairAlignmentLinkOrBuilder();

    /**
     * <code>optional uint32 fragment_index = 17;</code>
     *
     * <pre>
     * Index of the read fragment from which this alignment was obtained. 
     * </pre>
     */
    boolean hasFragmentIndex();
    /**
     * <code>optional uint32 fragment_index = 17;</code>
     *
     * <pre>
     * Index of the read fragment from which this alignment was obtained. 
     * </pre>
     */
    int getFragmentIndex();

    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    boolean hasSplicedForwardAlignmentLink();
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getSplicedForwardAlignmentLink();
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getSplicedForwardAlignmentLinkOrBuilder();

    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    boolean hasSplicedBackwardAlignmentLink();
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getSplicedBackwardAlignmentLink();
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getSplicedBackwardAlignmentLinkOrBuilder();

    /**
     * <code>optional uint32 spliced_flags = 19;</code>
     *
     * <pre>
     *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
     *matching part of the read, and flag describes the spliced_alignment_link with these
     *binary flags:
     *000000001    normal
     *000000010    novel
     * </pre>
     */
    boolean hasSplicedFlags();
    /**
     * <code>optional uint32 spliced_flags = 19;</code>
     *
     * <pre>
     *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
     *matching part of the read, and flag describes the spliced_alignment_link with these
     *binary flags:
     *000000001    normal
     *000000010    novel
     * </pre>
     */
    int getSplicedFlags();

    /**
     * <code>optional sint32 insert_size = 20;</code>
     *
     * <pre>
     * The size of the insert used when making the sequence library. This is the total size of the DNA
     *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
     *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
     *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
     * </pre>
     */
    boolean hasInsertSize();
    /**
     * <code>optional sint32 insert_size = 20;</code>
     *
     * <pre>
     * The size of the insert used when making the sequence library. This is the total size of the DNA
     *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
     *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
     *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
     * </pre>
     */
    int getInsertSize();

    /**
     * <code>optional uint32 sample_index = 21;</code>
     *
     * <pre>
     *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
     *alignment entry makes it possible to concat alignments from different origins and track what sample originally
     *contained each entry.
     * </pre>
     */
    boolean hasSampleIndex();
    /**
     * <code>optional uint32 sample_index = 21;</code>
     *
     * <pre>
     *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
     *alignment entry makes it possible to concat alignments from different origins and track what sample originally
     *contained each entry.
     * </pre>
     */
    int getSampleIndex();

    /**
     * <code>optional uint32 query_index_occurrences = 25;</code>
     *
     * <pre>
     *The total number of times the query index associated with this entry occurs across the entire alignment file.
     *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
     *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
     *query_index_occurrences is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasQueryIndexOccurrences();
    /**
     * <code>optional uint32 query_index_occurrences = 25;</code>
     *
     * <pre>
     *The total number of times the query index associated with this entry occurs across the entire alignment file.
     *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
     *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
     *query_index_occurrences is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getQueryIndexOccurrences();

    /**
     * <code>optional uint32 ambiguity = 27;</code>
     *
     * <pre>
     *The total number of times the read matches the reference across the entire alignment file. This differs from
     *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
     *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
     *entries to smaller thresholds). When each entry has a value for this field, the header field
     *ambiguity_stored_in_entries is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasAmbiguity();
    /**
     * <code>optional uint32 ambiguity = 27;</code>
     *
     * <pre>
     *The total number of times the read matches the reference across the entire alignment file. This differs from
     *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
     *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
     *entries to smaller thresholds). When each entry has a value for this field, the header field
     *ambiguity_stored_in_entries is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getAmbiguity();

    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    com.google.protobuf.ProtocolStringList
        getBamAttributesList();
    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    int getBamAttributesCount();
    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    java.lang.String getBamAttributes(int index);
    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    com.google.protobuf.ByteString
        getBamAttributesBytes(int index);

    /**
     * <code>optional bytes read_quality_scores = 55;</code>
     *
     * <pre>
     *Quality scores for all bases of the read.
     *Since Goby 2.0.
     * </pre>
     */
    boolean hasReadQualityScores();
    /**
     * <code>optional bytes read_quality_scores = 55;</code>
     *
     * <pre>
     *Quality scores for all bases of the read.
     *Since Goby 2.0.
     * </pre>
     */
    com.google.protobuf.ByteString getReadQualityScores();

    /**
     * <code>optional uint32 read_origin_index = 26;</code>
     *
     * <pre>
     *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
     *makes it possible to track the origin of the read (especially useful after several alignments
     *have been merged/concatenated).
     *(Since Goby 2.0).
     * </pre>
     */
    boolean hasReadOriginIndex();
    /**
     * <code>optional uint32 read_origin_index = 26;</code>
     *
     * <pre>
     *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
     *makes it possible to track the origin of the read (especially useful after several alignments
     *have been merged/concatenated).
     *(Since Goby 2.0).
     * </pre>
     */
    int getReadOriginIndex();

    /**
     * <code>optional string softClippedBasesLeft = 30;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
     *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
     * </pre>
     */
    boolean hasSoftClippedBasesLeft();
    /**
     * <code>optional string softClippedBasesLeft = 30;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
     *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
     * </pre>
     */
    java.lang.String getSoftClippedBasesLeft();
    /**
     * <code>optional string softClippedBasesLeft = 30;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
     *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
     * </pre>
     */
    com.google.protobuf.ByteString
        getSoftClippedBasesLeftBytes();

    /**
     * <code>optional string softClippedBasesRight = 31;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. The number of bases in softClippedBasesRight is exactly equal
     *to  queryLength - queryAlignedLength - queryPosition.
     * </pre>
     */
    boolean hasSoftClippedBasesRight();
    /**
     * <code>optional string softClippedBasesRight = 31;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. The number of bases in softClippedBasesRight is exactly equal
     *to  queryLength - queryAlignedLength - queryPosition.
     * </pre>
     */
    java.lang.String getSoftClippedBasesRight();
    /**
     * <code>optional string softClippedBasesRight = 31;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. The number of bases in softClippedBasesRight is exactly equal
     *to  queryLength - queryAlignedLength - queryPosition.
     * </pre>
     */
    com.google.protobuf.ByteString
        getSoftClippedBasesRightBytes();

    /**
     * <code>optional bytes softClippedQualityLeft = 32;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
     * </pre>
     */
    boolean hasSoftClippedQualityLeft();
    /**
     * <code>optional bytes softClippedQualityLeft = 32;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
     * </pre>
     */
    com.google.protobuf.ByteString getSoftClippedQualityLeft();

    /**
     * <code>optional bytes softClippedQualityRight = 33;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
     * </pre>
     */
    boolean hasSoftClippedQualityRight();
    /**
     * <code>optional bytes softClippedQualityRight = 33;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
     * </pre>
     */
    com.google.protobuf.ByteString getSoftClippedQualityRight();

    /**
     * <code>optional string placedUnmappedSequence = 40;</code>
     *
     * <pre>
     *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
     *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
     *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
     *from the reads file.
     * </pre>
     */
    boolean hasPlacedUnmappedSequence();
    /**
     * <code>optional string placedUnmappedSequence = 40;</code>
     *
     * <pre>
     *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
     *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
     *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
     *from the reads file.
     * </pre>
     */
    java.lang.String getPlacedUnmappedSequence();
    /**
     * <code>optional string placedUnmappedSequence = 40;</code>
     *
     * <pre>
     *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
     *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
     *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
     *from the reads file.
     * </pre>
     */
    com.google.protobuf.ByteString
        getPlacedUnmappedSequenceBytes();

    /**
     * <code>optional bytes placedUnmappedQuality = 41;</code>
     *
     * <pre>
     *Quality scores for a read placed near this entry.  Phred units.
     * </pre>
     */
    boolean hasPlacedUnmappedQuality();
    /**
     * <code>optional bytes placedUnmappedQuality = 41;</code>
     *
     * <pre>
     *Quality scores for a read placed near this entry.  Phred units.
     * </pre>
     */
    com.google.protobuf.ByteString getPlacedUnmappedQuality();

    /**
     * <code>optional string readName = 42;</code>
     *
     * <pre>
     *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
     * </pre>
     */
    boolean hasReadName();
    /**
     * <code>optional string readName = 42;</code>
     *
     * <pre>
     *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
     * </pre>
     */
    java.lang.String getReadName();
    /**
     * <code>optional string readName = 42;</code>
     *
     * <pre>
     *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
     * </pre>
     */
    com.google.protobuf.ByteString
        getReadNameBytes();
  }
  /**
   * Protobuf type {@code goby.AlignmentEntry}
   */
  public static final class AlignmentEntry extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.AlignmentEntry)
      AlignmentEntryOrBuilder {
    // Use AlignmentEntry.newBuilder() to construct.
    private AlignmentEntry(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private AlignmentEntry(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final AlignmentEntry defaultInstance;
    public static AlignmentEntry getDefaultInstance() {
      return defaultInstance;
    }

    public AlignmentEntry getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private AlignmentEntry(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000002;
              queryIndex_ = input.readUInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000004;
              targetIndex_ = input.readUInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000008;
              position_ = input.readUInt32();
              break;
            }
            case 37: {
              bitField0_ |= 0x00000040;
              score_ = input.readFloat();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000020;
              queryPosition_ = input.readUInt32();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000010;
              matchingReverseStrand_ = input.readBool();
              break;
            }
            case 56: {
              bitField0_ |= 0x00000001;
              multiplicity_ = input.readUInt32();
              break;
            }
            case 64: {
              bitField0_ |= 0x00000080;
              numberOfMismatches_ = input.readUInt32();
              break;
            }
            case 72: {
              bitField0_ |= 0x00000100;
              numberOfIndels_ = input.readUInt32();
              break;
            }
            case 80: {
              bitField0_ |= 0x00000800;
              queryLength_ = input.readUInt32();
              break;
            }
            case 88: {
              bitField0_ |= 0x00000200;
              queryAlignedLength_ = input.readUInt32();
              break;
            }
            case 96: {
              bitField0_ |= 0x00000400;
              targetAlignedLength_ = input.readUInt32();
              break;
            }
            case 106: {
              if (!((mutable_bitField0_ & 0x00000800) == 0x00000800)) {
                sequenceVariations_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation>();
                mutable_bitField0_ |= 0x00000800;
              }
              sequenceVariations_.add(input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.PARSER, extensionRegistry));
              break;
            }
            case 112: {
              bitField0_ |= 0x00001000;
              mappingQuality_ = input.readInt32();
              break;
            }
            case 120: {
              bitField0_ |= 0x00002000;
              pairFlags_ = input.readUInt32();
              break;
            }
            case 130: {
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder subBuilder = null;
              if (((bitField0_ & 0x00004000) == 0x00004000)) {
                subBuilder = pairAlignmentLink_.toBuilder();
              }
              pairAlignmentLink_ = input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(pairAlignmentLink_);
                pairAlignmentLink_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00004000;
              break;
            }
            case 136: {
              bitField0_ |= 0x00008000;
              fragmentIndex_ = input.readUInt32();
              break;
            }
            case 146: {
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder subBuilder = null;
              if (((bitField0_ & 0x00010000) == 0x00010000)) {
                subBuilder = splicedForwardAlignmentLink_.toBuilder();
              }
              splicedForwardAlignmentLink_ = input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(splicedForwardAlignmentLink_);
                splicedForwardAlignmentLink_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00010000;
              break;
            }
            case 152: {
              bitField0_ |= 0x00040000;
              splicedFlags_ = input.readUInt32();
              break;
            }
            case 160: {
              bitField0_ |= 0x00080000;
              insertSize_ = input.readSInt32();
              break;
            }
            case 168: {
              bitField0_ |= 0x00100000;
              sampleIndex_ = input.readUInt32();
              break;
            }
            case 178: {
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder subBuilder = null;
              if (((bitField0_ & 0x00020000) == 0x00020000)) {
                subBuilder = splicedBackwardAlignmentLink_.toBuilder();
              }
              splicedBackwardAlignmentLink_ = input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(splicedBackwardAlignmentLink_);
                splicedBackwardAlignmentLink_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00020000;
              break;
            }
            case 200: {
              bitField0_ |= 0x00200000;
              queryIndexOccurrences_ = input.readUInt32();
              break;
            }
            case 208: {
              bitField0_ |= 0x01000000;
              readOriginIndex_ = input.readUInt32();
              break;
            }
            case 216: {
              bitField0_ |= 0x00400000;
              ambiguity_ = input.readUInt32();
              break;
            }
            case 242: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x02000000;
              softClippedBasesLeft_ = bs;
              break;
            }
            case 250: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x04000000;
              softClippedBasesRight_ = bs;
              break;
            }
            case 258: {
              bitField0_ |= 0x08000000;
              softClippedQualityLeft_ = input.readBytes();
              break;
            }
            case 266: {
              bitField0_ |= 0x10000000;
              softClippedQualityRight_ = input.readBytes();
              break;
            }
            case 322: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x20000000;
              placedUnmappedSequence_ = bs;
              break;
            }
            case 330: {
              bitField0_ |= 0x40000000;
              placedUnmappedQuality_ = input.readBytes();
              break;
            }
            case 338: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x80000000;
              readName_ = bs;
              break;
            }
            case 402: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x01000000) == 0x01000000)) {
                bamAttributes_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x01000000;
              }
              bamAttributes_.add(bs);
              break;
            }
            case 442: {
              bitField0_ |= 0x00800000;
              readQualityScores_ = input.readBytes();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000800) == 0x00000800)) {
          sequenceVariations_ = java.util.Collections.unmodifiableList(sequenceVariations_);
        }
        if (((mutable_bitField0_ & 0x01000000) == 0x01000000)) {
          bamAttributes_ = bamAttributes_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentEntry_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentEntry_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder.class);
    }

    public static com.google.protobuf.Parser<AlignmentEntry> PARSER =
        new com.google.protobuf.AbstractParser<AlignmentEntry>() {
      public AlignmentEntry parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AlignmentEntry(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<AlignmentEntry> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int MULTIPLICITY_FIELD_NUMBER = 7;
    private int multiplicity_;
    /**
     * <code>optional uint32 multiplicity = 7;</code>
     *
     * <pre>
     * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
     *query redundancy had not been removed by read factorization.
     * </pre>
     */
    public boolean hasMultiplicity() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional uint32 multiplicity = 7;</code>
     *
     * <pre>
     * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
     *query redundancy had not been removed by read factorization.
     * </pre>
     */
    public int getMultiplicity() {
      return multiplicity_;
    }

    public static final int QUERY_INDEX_FIELD_NUMBER = 1;
    private int queryIndex_;
    /**
     * <code>optional uint32 query_index = 1;</code>
     *
     * <pre>
     * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
     *alignment runs are made with the same set of query sequences, equality of query index means that the query
     *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasQueryIndex() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional uint32 query_index = 1;</code>
     *
     * <pre>
     * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
     *alignment runs are made with the same set of query sequences, equality of query index means that the query
     *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getQueryIndex() {
      return queryIndex_;
    }

    public static final int TARGET_INDEX_FIELD_NUMBER = 2;
    private int targetIndex_;
    /**
     * <code>optional uint32 target_index = 2;</code>
     *
     * <pre>
     * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
     *alignment runs are made with the same set of target sequences, equality of target index means that the target
     *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasTargetIndex() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional uint32 target_index = 2;</code>
     *
     * <pre>
     * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
     *alignment runs are made with the same set of target sequences, equality of target index means that the target
     *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getTargetIndex() {
      return targetIndex_;
    }

    public static final int POSITION_FIELD_NUMBER = 3;
    private int position_;
    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position on the target of the start of the alignment between the query and the target.
     *In the following example, position is 3 because the third base of the query 'C' was aligned with
     *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
     *alignment can start at a mismatch if it was so constructed by the aligner.
     *0123456789
     *AAAAGTCAAA  target
     *ctCGTC     query
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasPosition() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position on the target of the start of the alignment between the query and the target.
     *In the following example, position is 3 because the third base of the query 'C' was aligned with
     *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
     *alignment can start at a mismatch if it was so constructed by the aligner.
     *0123456789
     *AAAAGTCAAA  target
     *ctCGTC     query
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getPosition() {
      return position_;
    }

    public static final int MATCHING_REVERSE_STRAND_FIELD_NUMBER = 6;
    private boolean matchingReverseStrand_;
    /**
     * <code>optional bool matching_reverse_strand = 6;</code>
     *
     * <pre>
     *True when the query matches the target on the reverse strand
     * </pre>
     */
    public boolean hasMatchingReverseStrand() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional bool matching_reverse_strand = 6;</code>
     *
     * <pre>
     *True when the query matches the target on the reverse strand
     * </pre>
     */
    public boolean getMatchingReverseStrand() {
      return matchingReverseStrand_;
    }

    public static final int QUERY_POSITION_FIELD_NUMBER = 5;
    private int queryPosition_;
    /**
     * <code>optional uint32 query_position = 5;</code>
     *
     * <pre>
     *The position on the query where the alignment starts. This value is different from zero
     *when some bases/residues of the query could not be aligned with the target.
     *TODO: Rename this to left_trim. Add a right_trim property.
     * </pre>
     */
    public boolean hasQueryPosition() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional uint32 query_position = 5;</code>
     *
     * <pre>
     *The position on the query where the alignment starts. This value is different from zero
     *when some bases/residues of the query could not be aligned with the target.
     *TODO: Rename this to left_trim. Add a right_trim property.
     * </pre>
     */
    public int getQueryPosition() {
      return queryPosition_;
    }

    public static final int SCORE_FIELD_NUMBER = 4;
    private float score_;
    /**
     * <code>optional float score = 4;</code>
     *
     * <pre>
     *The score of the alignment, where larger scores indicate better matches between the query and the target.
     *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
     *-(#mismatches(query,target)).
     * </pre>
     */
    public boolean hasScore() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional float score = 4;</code>
     *
     * <pre>
     *The score of the alignment, where larger scores indicate better matches between the query and the target.
     *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
     *-(#mismatches(query,target)).
     * </pre>
     */
    public float getScore() {
      return score_;
    }

    public static final int NUMBER_OF_MISMATCHES_FIELD_NUMBER = 8;
    private int numberOfMismatches_;
    /**
     * <code>optional uint32 number_of_mismatches = 8;</code>
     *
     * <pre>
     *Number of bases/residues that differ in the alignment between query and target sequences.
     * </pre>
     */
    public boolean hasNumberOfMismatches() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional uint32 number_of_mismatches = 8;</code>
     *
     * <pre>
     *Number of bases/residues that differ in the alignment between query and target sequences.
     * </pre>
     */
    public int getNumberOfMismatches() {
      return numberOfMismatches_;
    }

    public static final int NUMBER_OF_INDELS_FIELD_NUMBER = 9;
    private int numberOfIndels_;
    /**
     * <code>optional uint32 number_of_indels = 9;</code>
     *
     * <pre>
     *Cumulative number of insertions and/or deletions present in the alignment.
     * </pre>
     */
    public boolean hasNumberOfIndels() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional uint32 number_of_indels = 9;</code>
     *
     * <pre>
     *Cumulative number of insertions and/or deletions present in the alignment.
     * </pre>
     */
    public int getNumberOfIndels() {
      return numberOfIndels_;
    }

    public static final int QUERY_ALIGNED_LENGTH_FIELD_NUMBER = 11;
    private int queryAlignedLength_;
    /**
     * <code>optional uint32 query_aligned_length = 11;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
     *less or equal to query_length.
     * </pre>
     */
    public boolean hasQueryAlignedLength() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional uint32 query_aligned_length = 11;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
     *less or equal to query_length.
     * </pre>
     */
    public int getQueryAlignedLength() {
      return queryAlignedLength_;
    }

    public static final int TARGET_ALIGNED_LENGTH_FIELD_NUMBER = 12;
    private int targetAlignedLength_;
    /**
     * <code>optional uint32 target_aligned_length = 12;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the target.
     * </pre>
     */
    public boolean hasTargetAlignedLength() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional uint32 target_aligned_length = 12;</code>
     *
     * <pre>
     *Number of bases that have been aligned for the target.
     * </pre>
     */
    public int getTargetAlignedLength() {
      return targetAlignedLength_;
    }

    public static final int SEQUENCE_VARIATIONS_FIELD_NUMBER = 13;
    private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation> sequenceVariations_;
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation> getSequenceVariationsList() {
      return sequenceVariations_;
    }
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder> 
        getSequenceVariationsOrBuilderList() {
      return sequenceVariations_;
    }
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    public int getSequenceVariationsCount() {
      return sequenceVariations_.size();
    }
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation getSequenceVariations(int index) {
      return sequenceVariations_.get(index);
    }
    /**
     * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder getSequenceVariationsOrBuilder(
        int index) {
      return sequenceVariations_.get(index);
    }

    public static final int QUERY_LENGTH_FIELD_NUMBER = 10;
    private int queryLength_;
    /**
     * <code>optional uint32 query_length = 10;</code>
     *
     * <pre>
     *Length of the query sequence.
     * </pre>
     */
    public boolean hasQueryLength() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional uint32 query_length = 10;</code>
     *
     * <pre>
     *Length of the query sequence.
     * </pre>
     */
    public int getQueryLength() {
      return queryLength_;
    }

    public static final int MAPPING_QUALITY_FIELD_NUMBER = 14;
    private int mappingQuality_;
    /**
     * <code>optional int32 mapping_quality = 14;</code>
     *
     * <pre>
     *Mapping Quality (phred-scaled posterior probability that the mapping
     *position of this read is incorrect). Please note that different aligners
     *may estimate mapping quality with different approaches, resulting in aligner
     *specific differences in the distribution of mapping quality. It is recommended
     *to condition mapping quality on the aligner that produced the specific alignment
     *being processed. See aligner name and version in the header.
     *Note that the following description is preliminary. A clear specification is
     *needed:
     *The mapping quality should be proportional to the
     *log of the probability that the given mapping is the "correct" one.
     *So if there are five equally good mappings of a read to the genome,
     *the probability of each would be 0.2, and the mapping quality would be
     *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
     *say a 1e-4 of it being wrong, then the mapping quality would be
     *-10*log10(1e-4) = 40.
     * </pre>
     */
    public boolean hasMappingQuality() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <code>optional int32 mapping_quality = 14;</code>
     *
     * <pre>
     *Mapping Quality (phred-scaled posterior probability that the mapping
     *position of this read is incorrect). Please note that different aligners
     *may estimate mapping quality with different approaches, resulting in aligner
     *specific differences in the distribution of mapping quality. It is recommended
     *to condition mapping quality on the aligner that produced the specific alignment
     *being processed. See aligner name and version in the header.
     *Note that the following description is preliminary. A clear specification is
     *needed:
     *The mapping quality should be proportional to the
     *log of the probability that the given mapping is the "correct" one.
     *So if there are five equally good mappings of a read to the genome,
     *the probability of each would be 0.2, and the mapping quality would be
     *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
     *say a 1e-4 of it being wrong, then the mapping quality would be
     *-10*log10(1e-4) = 40.
     * </pre>
     */
    public int getMappingQuality() {
      return mappingQuality_;
    }

    public static final int PAIR_FLAGS_FIELD_NUMBER = 15;
    private int pairFlags_;
    /**
     * <code>optional uint32 pair_flags = 15;</code>
     *
     * <pre>
     *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
     *000000001    paired
     *000000010    properly paired
     *000000100    read unmapped
     *000001000    mate unmapped
     *000010000    read reverse strand
     *000100000    mate reverse strand
     *001000000    first in pair
     *010000000    second in pair
     *100000000    not primary alignment
     * </pre>
     */
    public boolean hasPairFlags() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <code>optional uint32 pair_flags = 15;</code>
     *
     * <pre>
     *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
     *000000001    paired
     *000000010    properly paired
     *000000100    read unmapped
     *000001000    mate unmapped
     *000010000    read reverse strand
     *000100000    mate reverse strand
     *001000000    first in pair
     *010000000    second in pair
     *100000000    not primary alignment
     * </pre>
     */
    public int getPairFlags() {
      return pairFlags_;
    }

    public static final int PAIR_ALIGNMENT_LINK_FIELD_NUMBER = 16;
    private edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry pairAlignmentLink_;
    /**
     * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
     *
     * <pre>
     *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
     * </pre>
     */
    public boolean hasPairAlignmentLink() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
     *
     * <pre>
     *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getPairAlignmentLink() {
      return pairAlignmentLink_;
    }
    /**
     * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
     *
     * <pre>
     *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getPairAlignmentLinkOrBuilder() {
      return pairAlignmentLink_;
    }

    public static final int FRAGMENT_INDEX_FIELD_NUMBER = 17;
    private int fragmentIndex_;
    /**
     * <code>optional uint32 fragment_index = 17;</code>
     *
     * <pre>
     * Index of the read fragment from which this alignment was obtained. 
     * </pre>
     */
    public boolean hasFragmentIndex() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <code>optional uint32 fragment_index = 17;</code>
     *
     * <pre>
     * Index of the read fragment from which this alignment was obtained. 
     * </pre>
     */
    public int getFragmentIndex() {
      return fragmentIndex_;
    }

    public static final int SPLICED_FORWARD_ALIGNMENT_LINK_FIELD_NUMBER = 18;
    private edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry splicedForwardAlignmentLink_;
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    public boolean hasSplicedForwardAlignmentLink() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getSplicedForwardAlignmentLink() {
      return splicedForwardAlignmentLink_;
    }
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getSplicedForwardAlignmentLinkOrBuilder() {
      return splicedForwardAlignmentLink_;
    }

    public static final int SPLICED_BACKWARD_ALIGNMENT_LINK_FIELD_NUMBER = 22;
    private edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry splicedBackwardAlignmentLink_;
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    public boolean hasSplicedBackwardAlignmentLink() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getSplicedBackwardAlignmentLink() {
      return splicedBackwardAlignmentLink_;
    }
    /**
     * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
     *
     * <pre>
     * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
     *alignment entries, one for each matching part of the read, and link these entries with
     *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
     *AlignmentEntry in the chain of spliced alignments.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getSplicedBackwardAlignmentLinkOrBuilder() {
      return splicedBackwardAlignmentLink_;
    }

    public static final int SPLICED_FLAGS_FIELD_NUMBER = 19;
    private int splicedFlags_;
    /**
     * <code>optional uint32 spliced_flags = 19;</code>
     *
     * <pre>
     *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
     *matching part of the read, and flag describes the spliced_alignment_link with these
     *binary flags:
     *000000001    normal
     *000000010    novel
     * </pre>
     */
    public boolean hasSplicedFlags() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <code>optional uint32 spliced_flags = 19;</code>
     *
     * <pre>
     *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
     *matching part of the read, and flag describes the spliced_alignment_link with these
     *binary flags:
     *000000001    normal
     *000000010    novel
     * </pre>
     */
    public int getSplicedFlags() {
      return splicedFlags_;
    }

    public static final int INSERT_SIZE_FIELD_NUMBER = 20;
    private int insertSize_;
    /**
     * <code>optional sint32 insert_size = 20;</code>
     *
     * <pre>
     * The size of the insert used when making the sequence library. This is the total size of the DNA
     *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
     *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
     *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
     * </pre>
     */
    public boolean hasInsertSize() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <code>optional sint32 insert_size = 20;</code>
     *
     * <pre>
     * The size of the insert used when making the sequence library. This is the total size of the DNA
     *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
     *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
     *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
     * </pre>
     */
    public int getInsertSize() {
      return insertSize_;
    }

    public static final int SAMPLE_INDEX_FIELD_NUMBER = 21;
    private int sampleIndex_;
    /**
     * <code>optional uint32 sample_index = 21;</code>
     *
     * <pre>
     *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
     *alignment entry makes it possible to concat alignments from different origins and track what sample originally
     *contained each entry.
     * </pre>
     */
    public boolean hasSampleIndex() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <code>optional uint32 sample_index = 21;</code>
     *
     * <pre>
     *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
     *alignment entry makes it possible to concat alignments from different origins and track what sample originally
     *contained each entry.
     * </pre>
     */
    public int getSampleIndex() {
      return sampleIndex_;
    }

    public static final int QUERY_INDEX_OCCURRENCES_FIELD_NUMBER = 25;
    private int queryIndexOccurrences_;
    /**
     * <code>optional uint32 query_index_occurrences = 25;</code>
     *
     * <pre>
     *The total number of times the query index associated with this entry occurs across the entire alignment file.
     *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
     *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
     *query_index_occurrences is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasQueryIndexOccurrences() {
      return ((bitField0_ & 0x00200000) == 0x00200000);
    }
    /**
     * <code>optional uint32 query_index_occurrences = 25;</code>
     *
     * <pre>
     *The total number of times the query index associated with this entry occurs across the entire alignment file.
     *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
     *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
     *query_index_occurrences is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getQueryIndexOccurrences() {
      return queryIndexOccurrences_;
    }

    public static final int AMBIGUITY_FIELD_NUMBER = 27;
    private int ambiguity_;
    /**
     * <code>optional uint32 ambiguity = 27;</code>
     *
     * <pre>
     *The total number of times the read matches the reference across the entire alignment file. This differs from
     *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
     *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
     *entries to smaller thresholds). When each entry has a value for this field, the header field
     *ambiguity_stored_in_entries is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasAmbiguity() {
      return ((bitField0_ & 0x00400000) == 0x00400000);
    }
    /**
     * <code>optional uint32 ambiguity = 27;</code>
     *
     * <pre>
     *The total number of times the read matches the reference across the entire alignment file. This differs from
     *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
     *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
     *entries to smaller thresholds). When each entry has a value for this field, the header field
     *ambiguity_stored_in_entries is true.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getAmbiguity() {
      return ambiguity_;
    }

    public static final int BAM_ATTRIBUTES_FIELD_NUMBER = 50;
    private com.google.protobuf.LazyStringList bamAttributes_;
    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    public com.google.protobuf.ProtocolStringList
        getBamAttributesList() {
      return bamAttributes_;
    }
    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    public int getBamAttributesCount() {
      return bamAttributes_.size();
    }
    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    public java.lang.String getBamAttributes(int index) {
      return bamAttributes_.get(index);
    }
    /**
     * <code>repeated string bam_attributes = 50;</code>
     *
     * <pre>
     *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
     *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
     *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
     *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
     *the corresponding goby native fields.
     *Since Goby 2.0.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getBamAttributesBytes(int index) {
      return bamAttributes_.getByteString(index);
    }

    public static final int READ_QUALITY_SCORES_FIELD_NUMBER = 55;
    private com.google.protobuf.ByteString readQualityScores_;
    /**
     * <code>optional bytes read_quality_scores = 55;</code>
     *
     * <pre>
     *Quality scores for all bases of the read.
     *Since Goby 2.0.
     * </pre>
     */
    public boolean hasReadQualityScores() {
      return ((bitField0_ & 0x00800000) == 0x00800000);
    }
    /**
     * <code>optional bytes read_quality_scores = 55;</code>
     *
     * <pre>
     *Quality scores for all bases of the read.
     *Since Goby 2.0.
     * </pre>
     */
    public com.google.protobuf.ByteString getReadQualityScores() {
      return readQualityScores_;
    }

    public static final int READ_ORIGIN_INDEX_FIELD_NUMBER = 26;
    private int readOriginIndex_;
    /**
     * <code>optional uint32 read_origin_index = 26;</code>
     *
     * <pre>
     *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
     *makes it possible to track the origin of the read (especially useful after several alignments
     *have been merged/concatenated).
     *(Since Goby 2.0).
     * </pre>
     */
    public boolean hasReadOriginIndex() {
      return ((bitField0_ & 0x01000000) == 0x01000000);
    }
    /**
     * <code>optional uint32 read_origin_index = 26;</code>
     *
     * <pre>
     *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
     *makes it possible to track the origin of the read (especially useful after several alignments
     *have been merged/concatenated).
     *(Since Goby 2.0).
     * </pre>
     */
    public int getReadOriginIndex() {
      return readOriginIndex_;
    }

    public static final int SOFTCLIPPEDBASESLEFT_FIELD_NUMBER = 30;
    private java.lang.Object softClippedBasesLeft_;
    /**
     * <code>optional string softClippedBasesLeft = 30;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
     *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
     * </pre>
     */
    public boolean hasSoftClippedBasesLeft() {
      return ((bitField0_ & 0x02000000) == 0x02000000);
    }
    /**
     * <code>optional string softClippedBasesLeft = 30;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
     *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
     * </pre>
     */
    public java.lang.String getSoftClippedBasesLeft() {
      java.lang.Object ref = softClippedBasesLeft_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          softClippedBasesLeft_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string softClippedBasesLeft = 30;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
     *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getSoftClippedBasesLeftBytes() {
      java.lang.Object ref = softClippedBasesLeft_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        softClippedBasesLeft_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOFTCLIPPEDBASESRIGHT_FIELD_NUMBER = 31;
    private java.lang.Object softClippedBasesRight_;
    /**
     * <code>optional string softClippedBasesRight = 31;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. The number of bases in softClippedBasesRight is exactly equal
     *to  queryLength - queryAlignedLength - queryPosition.
     * </pre>
     */
    public boolean hasSoftClippedBasesRight() {
      return ((bitField0_ & 0x04000000) == 0x04000000);
    }
    /**
     * <code>optional string softClippedBasesRight = 31;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. The number of bases in softClippedBasesRight is exactly equal
     *to  queryLength - queryAlignedLength - queryPosition.
     * </pre>
     */
    public java.lang.String getSoftClippedBasesRight() {
      java.lang.Object ref = softClippedBasesRight_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          softClippedBasesRight_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string softClippedBasesRight = 31;</code>
     *
     * <pre>
     *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
     *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
     *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
     *the reference base. The number of bases in softClippedBasesRight is exactly equal
     *to  queryLength - queryAlignedLength - queryPosition.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getSoftClippedBasesRightBytes() {
      java.lang.Object ref = softClippedBasesRight_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        softClippedBasesRight_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOFTCLIPPEDQUALITYLEFT_FIELD_NUMBER = 32;
    private com.google.protobuf.ByteString softClippedQualityLeft_;
    /**
     * <code>optional bytes softClippedQualityLeft = 32;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
     * </pre>
     */
    public boolean hasSoftClippedQualityLeft() {
      return ((bitField0_ & 0x08000000) == 0x08000000);
    }
    /**
     * <code>optional bytes softClippedQualityLeft = 32;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
     * </pre>
     */
    public com.google.protobuf.ByteString getSoftClippedQualityLeft() {
      return softClippedQualityLeft_;
    }

    public static final int SOFTCLIPPEDQUALITYRIGHT_FIELD_NUMBER = 33;
    private com.google.protobuf.ByteString softClippedQualityRight_;
    /**
     * <code>optional bytes softClippedQualityRight = 33;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
     * </pre>
     */
    public boolean hasSoftClippedQualityRight() {
      return ((bitField0_ & 0x10000000) == 0x10000000);
    }
    /**
     * <code>optional bytes softClippedQualityRight = 33;</code>
     *
     * <pre>
     *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
     * </pre>
     */
    public com.google.protobuf.ByteString getSoftClippedQualityRight() {
      return softClippedQualityRight_;
    }

    public static final int PLACEDUNMAPPEDSEQUENCE_FIELD_NUMBER = 40;
    private java.lang.Object placedUnmappedSequence_;
    /**
     * <code>optional string placedUnmappedSequence = 40;</code>
     *
     * <pre>
     *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
     *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
     *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
     *from the reads file.
     * </pre>
     */
    public boolean hasPlacedUnmappedSequence() {
      return ((bitField0_ & 0x20000000) == 0x20000000);
    }
    /**
     * <code>optional string placedUnmappedSequence = 40;</code>
     *
     * <pre>
     *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
     *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
     *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
     *from the reads file.
     * </pre>
     */
    public java.lang.String getPlacedUnmappedSequence() {
      java.lang.Object ref = placedUnmappedSequence_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          placedUnmappedSequence_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string placedUnmappedSequence = 40;</code>
     *
     * <pre>
     *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
     *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
     *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
     *from the reads file.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPlacedUnmappedSequenceBytes() {
      java.lang.Object ref = placedUnmappedSequence_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        placedUnmappedSequence_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PLACEDUNMAPPEDQUALITY_FIELD_NUMBER = 41;
    private com.google.protobuf.ByteString placedUnmappedQuality_;
    /**
     * <code>optional bytes placedUnmappedQuality = 41;</code>
     *
     * <pre>
     *Quality scores for a read placed near this entry.  Phred units.
     * </pre>
     */
    public boolean hasPlacedUnmappedQuality() {
      return ((bitField0_ & 0x40000000) == 0x40000000);
    }
    /**
     * <code>optional bytes placedUnmappedQuality = 41;</code>
     *
     * <pre>
     *Quality scores for a read placed near this entry.  Phred units.
     * </pre>
     */
    public com.google.protobuf.ByteString getPlacedUnmappedQuality() {
      return placedUnmappedQuality_;
    }

    public static final int READNAME_FIELD_NUMBER = 42;
    private java.lang.Object readName_;
    /**
     * <code>optional string readName = 42;</code>
     *
     * <pre>
     *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
     * </pre>
     */
    public boolean hasReadName() {
      return ((bitField0_ & 0x80000000) == 0x80000000);
    }
    /**
     * <code>optional string readName = 42;</code>
     *
     * <pre>
     *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
     * </pre>
     */
    public java.lang.String getReadName() {
      java.lang.Object ref = readName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          readName_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string readName = 42;</code>
     *
     * <pre>
     *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getReadNameBytes() {
      java.lang.Object ref = readName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        readName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private void initFields() {
      multiplicity_ = 0;
      queryIndex_ = 0;
      targetIndex_ = 0;
      position_ = 0;
      matchingReverseStrand_ = false;
      queryPosition_ = 0;
      score_ = 0F;
      numberOfMismatches_ = 0;
      numberOfIndels_ = 0;
      queryAlignedLength_ = 0;
      targetAlignedLength_ = 0;
      sequenceVariations_ = java.util.Collections.emptyList();
      queryLength_ = 0;
      mappingQuality_ = 0;
      pairFlags_ = 0;
      pairAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
      fragmentIndex_ = 0;
      splicedForwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
      splicedBackwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
      splicedFlags_ = 0;
      insertSize_ = 0;
      sampleIndex_ = 0;
      queryIndexOccurrences_ = 0;
      ambiguity_ = 0;
      bamAttributes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      readQualityScores_ = com.google.protobuf.ByteString.EMPTY;
      readOriginIndex_ = 0;
      softClippedBasesLeft_ = "";
      softClippedBasesRight_ = "";
      softClippedQualityLeft_ = com.google.protobuf.ByteString.EMPTY;
      softClippedQualityRight_ = com.google.protobuf.ByteString.EMPTY;
      placedUnmappedSequence_ = "";
      placedUnmappedQuality_ = com.google.protobuf.ByteString.EMPTY;
      readName_ = "";
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(1, queryIndex_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt32(2, targetIndex_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt32(3, position_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeFloat(4, score_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeUInt32(5, queryPosition_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBool(6, matchingReverseStrand_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(7, multiplicity_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeUInt32(8, numberOfMismatches_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeUInt32(9, numberOfIndels_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeUInt32(10, queryLength_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeUInt32(11, queryAlignedLength_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeUInt32(12, targetAlignedLength_);
      }
      for (int i = 0; i < sequenceVariations_.size(); i++) {
        output.writeMessage(13, sequenceVariations_.get(i));
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeInt32(14, mappingQuality_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeUInt32(15, pairFlags_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeMessage(16, pairAlignmentLink_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeUInt32(17, fragmentIndex_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeMessage(18, splicedForwardAlignmentLink_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeUInt32(19, splicedFlags_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeSInt32(20, insertSize_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeUInt32(21, sampleIndex_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeMessage(22, splicedBackwardAlignmentLink_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        output.writeUInt32(25, queryIndexOccurrences_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        output.writeUInt32(26, readOriginIndex_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        output.writeUInt32(27, ambiguity_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        output.writeBytes(30, getSoftClippedBasesLeftBytes());
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        output.writeBytes(31, getSoftClippedBasesRightBytes());
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        output.writeBytes(32, softClippedQualityLeft_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        output.writeBytes(33, softClippedQualityRight_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        output.writeBytes(40, getPlacedUnmappedSequenceBytes());
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        output.writeBytes(41, placedUnmappedQuality_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        output.writeBytes(42, getReadNameBytes());
      }
      for (int i = 0; i < bamAttributes_.size(); i++) {
        output.writeBytes(50, bamAttributes_.getByteString(i));
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeBytes(55, readQualityScores_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, queryIndex_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, targetIndex_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, position_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(4, score_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, queryPosition_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, matchingReverseStrand_);
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, multiplicity_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(8, numberOfMismatches_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(9, numberOfIndels_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, queryLength_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, queryAlignedLength_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, targetAlignedLength_);
      }
      for (int i = 0; i < sequenceVariations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, sequenceVariations_.get(i));
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(14, mappingQuality_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(15, pairFlags_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, pairAlignmentLink_);
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(17, fragmentIndex_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, splicedForwardAlignmentLink_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(19, splicedFlags_);
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeSInt32Size(20, insertSize_);
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(21, sampleIndex_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, splicedBackwardAlignmentLink_);
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(25, queryIndexOccurrences_);
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(26, readOriginIndex_);
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(27, ambiguity_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(30, getSoftClippedBasesLeftBytes());
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(31, getSoftClippedBasesRightBytes());
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(32, softClippedQualityLeft_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(33, softClippedQualityRight_);
      }
      if (((bitField0_ & 0x20000000) == 0x20000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(40, getPlacedUnmappedSequenceBytes());
      }
      if (((bitField0_ & 0x40000000) == 0x40000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(41, placedUnmappedQuality_);
      }
      if (((bitField0_ & 0x80000000) == 0x80000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(42, getReadNameBytes());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < bamAttributes_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(bamAttributes_.getByteString(i));
        }
        size += dataSize;
        size += 2 * getBamAttributesList().size();
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(55, readQualityScores_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.AlignmentEntry}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.AlignmentEntry)
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentEntry_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentEntry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getSequenceVariationsFieldBuilder();
          getPairAlignmentLinkFieldBuilder();
          getSplicedForwardAlignmentLinkFieldBuilder();
          getSplicedBackwardAlignmentLinkFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        multiplicity_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        queryIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        targetIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        position_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        matchingReverseStrand_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        queryPosition_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        score_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000040);
        numberOfMismatches_ = 0;
        bitField0_ = (bitField0_ & ~0x00000080);
        numberOfIndels_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        queryAlignedLength_ = 0;
        bitField0_ = (bitField0_ & ~0x00000200);
        targetAlignedLength_ = 0;
        bitField0_ = (bitField0_ & ~0x00000400);
        if (sequenceVariationsBuilder_ == null) {
          sequenceVariations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
        } else {
          sequenceVariationsBuilder_.clear();
        }
        queryLength_ = 0;
        bitField0_ = (bitField0_ & ~0x00001000);
        mappingQuality_ = 0;
        bitField0_ = (bitField0_ & ~0x00002000);
        pairFlags_ = 0;
        bitField0_ = (bitField0_ & ~0x00004000);
        if (pairAlignmentLinkBuilder_ == null) {
          pairAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
        } else {
          pairAlignmentLinkBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00008000);
        fragmentIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00010000);
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          splicedForwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
        } else {
          splicedForwardAlignmentLinkBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00020000);
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          splicedBackwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
        } else {
          splicedBackwardAlignmentLinkBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00040000);
        splicedFlags_ = 0;
        bitField0_ = (bitField0_ & ~0x00080000);
        insertSize_ = 0;
        bitField0_ = (bitField0_ & ~0x00100000);
        sampleIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00200000);
        queryIndexOccurrences_ = 0;
        bitField0_ = (bitField0_ & ~0x00400000);
        ambiguity_ = 0;
        bitField0_ = (bitField0_ & ~0x00800000);
        bamAttributes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x01000000);
        readQualityScores_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x02000000);
        readOriginIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x04000000);
        softClippedBasesLeft_ = "";
        bitField0_ = (bitField0_ & ~0x08000000);
        softClippedBasesRight_ = "";
        bitField0_ = (bitField0_ & ~0x10000000);
        softClippedQualityLeft_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x20000000);
        softClippedQualityRight_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x40000000);
        placedUnmappedSequence_ = "";
        bitField0_ = (bitField0_ & ~0x80000000);
        placedUnmappedQuality_ = com.google.protobuf.ByteString.EMPTY;
        bitField1_ = (bitField1_ & ~0x00000001);
        readName_ = "";
        bitField1_ = (bitField1_ & ~0x00000002);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentEntry_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry build() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry result = new edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.multiplicity_ = multiplicity_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.queryIndex_ = queryIndex_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.targetIndex_ = targetIndex_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.position_ = position_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.matchingReverseStrand_ = matchingReverseStrand_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.queryPosition_ = queryPosition_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.score_ = score_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.numberOfMismatches_ = numberOfMismatches_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.numberOfIndels_ = numberOfIndels_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.queryAlignedLength_ = queryAlignedLength_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.targetAlignedLength_ = targetAlignedLength_;
        if (sequenceVariationsBuilder_ == null) {
          if (((bitField0_ & 0x00000800) == 0x00000800)) {
            sequenceVariations_ = java.util.Collections.unmodifiableList(sequenceVariations_);
            bitField0_ = (bitField0_ & ~0x00000800);
          }
          result.sequenceVariations_ = sequenceVariations_;
        } else {
          result.sequenceVariations_ = sequenceVariationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00000800;
        }
        result.queryLength_ = queryLength_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.mappingQuality_ = mappingQuality_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.pairFlags_ = pairFlags_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00004000;
        }
        if (pairAlignmentLinkBuilder_ == null) {
          result.pairAlignmentLink_ = pairAlignmentLink_;
        } else {
          result.pairAlignmentLink_ = pairAlignmentLinkBuilder_.build();
        }
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.fragmentIndex_ = fragmentIndex_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00010000;
        }
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          result.splicedForwardAlignmentLink_ = splicedForwardAlignmentLink_;
        } else {
          result.splicedForwardAlignmentLink_ = splicedForwardAlignmentLinkBuilder_.build();
        }
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00020000;
        }
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          result.splicedBackwardAlignmentLink_ = splicedBackwardAlignmentLink_;
        } else {
          result.splicedBackwardAlignmentLink_ = splicedBackwardAlignmentLinkBuilder_.build();
        }
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.splicedFlags_ = splicedFlags_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00080000;
        }
        result.insertSize_ = insertSize_;
        if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.sampleIndex_ = sampleIndex_;
        if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
          to_bitField0_ |= 0x00200000;
        }
        result.queryIndexOccurrences_ = queryIndexOccurrences_;
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00400000;
        }
        result.ambiguity_ = ambiguity_;
        if (((bitField0_ & 0x01000000) == 0x01000000)) {
          bamAttributes_ = bamAttributes_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x01000000);
        }
        result.bamAttributes_ = bamAttributes_;
        if (((from_bitField0_ & 0x02000000) == 0x02000000)) {
          to_bitField0_ |= 0x00800000;
        }
        result.readQualityScores_ = readQualityScores_;
        if (((from_bitField0_ & 0x04000000) == 0x04000000)) {
          to_bitField0_ |= 0x01000000;
        }
        result.readOriginIndex_ = readOriginIndex_;
        if (((from_bitField0_ & 0x08000000) == 0x08000000)) {
          to_bitField0_ |= 0x02000000;
        }
        result.softClippedBasesLeft_ = softClippedBasesLeft_;
        if (((from_bitField0_ & 0x10000000) == 0x10000000)) {
          to_bitField0_ |= 0x04000000;
        }
        result.softClippedBasesRight_ = softClippedBasesRight_;
        if (((from_bitField0_ & 0x20000000) == 0x20000000)) {
          to_bitField0_ |= 0x08000000;
        }
        result.softClippedQualityLeft_ = softClippedQualityLeft_;
        if (((from_bitField0_ & 0x40000000) == 0x40000000)) {
          to_bitField0_ |= 0x10000000;
        }
        result.softClippedQualityRight_ = softClippedQualityRight_;
        if (((from_bitField0_ & 0x80000000) == 0x80000000)) {
          to_bitField0_ |= 0x20000000;
        }
        result.placedUnmappedSequence_ = placedUnmappedSequence_;
        if (((from_bitField1_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x40000000;
        }
        result.placedUnmappedQuality_ = placedUnmappedQuality_;
        if (((from_bitField1_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x80000000;
        }
        result.readName_ = readName_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry.getDefaultInstance()) return this;
        if (other.hasMultiplicity()) {
          setMultiplicity(other.getMultiplicity());
        }
        if (other.hasQueryIndex()) {
          setQueryIndex(other.getQueryIndex());
        }
        if (other.hasTargetIndex()) {
          setTargetIndex(other.getTargetIndex());
        }
        if (other.hasPosition()) {
          setPosition(other.getPosition());
        }
        if (other.hasMatchingReverseStrand()) {
          setMatchingReverseStrand(other.getMatchingReverseStrand());
        }
        if (other.hasQueryPosition()) {
          setQueryPosition(other.getQueryPosition());
        }
        if (other.hasScore()) {
          setScore(other.getScore());
        }
        if (other.hasNumberOfMismatches()) {
          setNumberOfMismatches(other.getNumberOfMismatches());
        }
        if (other.hasNumberOfIndels()) {
          setNumberOfIndels(other.getNumberOfIndels());
        }
        if (other.hasQueryAlignedLength()) {
          setQueryAlignedLength(other.getQueryAlignedLength());
        }
        if (other.hasTargetAlignedLength()) {
          setTargetAlignedLength(other.getTargetAlignedLength());
        }
        if (sequenceVariationsBuilder_ == null) {
          if (!other.sequenceVariations_.isEmpty()) {
            if (sequenceVariations_.isEmpty()) {
              sequenceVariations_ = other.sequenceVariations_;
              bitField0_ = (bitField0_ & ~0x00000800);
            } else {
              ensureSequenceVariationsIsMutable();
              sequenceVariations_.addAll(other.sequenceVariations_);
            }
            onChanged();
          }
        } else {
          if (!other.sequenceVariations_.isEmpty()) {
            if (sequenceVariationsBuilder_.isEmpty()) {
              sequenceVariationsBuilder_.dispose();
              sequenceVariationsBuilder_ = null;
              sequenceVariations_ = other.sequenceVariations_;
              bitField0_ = (bitField0_ & ~0x00000800);
              sequenceVariationsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getSequenceVariationsFieldBuilder() : null;
            } else {
              sequenceVariationsBuilder_.addAllMessages(other.sequenceVariations_);
            }
          }
        }
        if (other.hasQueryLength()) {
          setQueryLength(other.getQueryLength());
        }
        if (other.hasMappingQuality()) {
          setMappingQuality(other.getMappingQuality());
        }
        if (other.hasPairFlags()) {
          setPairFlags(other.getPairFlags());
        }
        if (other.hasPairAlignmentLink()) {
          mergePairAlignmentLink(other.getPairAlignmentLink());
        }
        if (other.hasFragmentIndex()) {
          setFragmentIndex(other.getFragmentIndex());
        }
        if (other.hasSplicedForwardAlignmentLink()) {
          mergeSplicedForwardAlignmentLink(other.getSplicedForwardAlignmentLink());
        }
        if (other.hasSplicedBackwardAlignmentLink()) {
          mergeSplicedBackwardAlignmentLink(other.getSplicedBackwardAlignmentLink());
        }
        if (other.hasSplicedFlags()) {
          setSplicedFlags(other.getSplicedFlags());
        }
        if (other.hasInsertSize()) {
          setInsertSize(other.getInsertSize());
        }
        if (other.hasSampleIndex()) {
          setSampleIndex(other.getSampleIndex());
        }
        if (other.hasQueryIndexOccurrences()) {
          setQueryIndexOccurrences(other.getQueryIndexOccurrences());
        }
        if (other.hasAmbiguity()) {
          setAmbiguity(other.getAmbiguity());
        }
        if (!other.bamAttributes_.isEmpty()) {
          if (bamAttributes_.isEmpty()) {
            bamAttributes_ = other.bamAttributes_;
            bitField0_ = (bitField0_ & ~0x01000000);
          } else {
            ensureBamAttributesIsMutable();
            bamAttributes_.addAll(other.bamAttributes_);
          }
          onChanged();
        }
        if (other.hasReadQualityScores()) {
          setReadQualityScores(other.getReadQualityScores());
        }
        if (other.hasReadOriginIndex()) {
          setReadOriginIndex(other.getReadOriginIndex());
        }
        if (other.hasSoftClippedBasesLeft()) {
          bitField0_ |= 0x08000000;
          softClippedBasesLeft_ = other.softClippedBasesLeft_;
          onChanged();
        }
        if (other.hasSoftClippedBasesRight()) {
          bitField0_ |= 0x10000000;
          softClippedBasesRight_ = other.softClippedBasesRight_;
          onChanged();
        }
        if (other.hasSoftClippedQualityLeft()) {
          setSoftClippedQualityLeft(other.getSoftClippedQualityLeft());
        }
        if (other.hasSoftClippedQualityRight()) {
          setSoftClippedQualityRight(other.getSoftClippedQualityRight());
        }
        if (other.hasPlacedUnmappedSequence()) {
          bitField0_ |= 0x80000000;
          placedUnmappedSequence_ = other.placedUnmappedSequence_;
          onChanged();
        }
        if (other.hasPlacedUnmappedQuality()) {
          setPlacedUnmappedQuality(other.getPlacedUnmappedQuality());
        }
        if (other.hasReadName()) {
          bitField1_ |= 0x00000002;
          readName_ = other.readName_;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      private int multiplicity_ ;
      /**
       * <code>optional uint32 multiplicity = 7;</code>
       *
       * <pre>
       * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
       *query redundancy had not been removed by read factorization.
       * </pre>
       */
      public boolean hasMultiplicity() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional uint32 multiplicity = 7;</code>
       *
       * <pre>
       * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
       *query redundancy had not been removed by read factorization.
       * </pre>
       */
      public int getMultiplicity() {
        return multiplicity_;
      }
      /**
       * <code>optional uint32 multiplicity = 7;</code>
       *
       * <pre>
       * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
       *query redundancy had not been removed by read factorization.
       * </pre>
       */
      public Builder setMultiplicity(int value) {
        bitField0_ |= 0x00000001;
        multiplicity_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 multiplicity = 7;</code>
       *
       * <pre>
       * Multiplicity of this entry. The number of times this  alignment entry would be repeated exactly the same if
       *query redundancy had not been removed by read factorization.
       * </pre>
       */
      public Builder clearMultiplicity() {
        bitField0_ = (bitField0_ & ~0x00000001);
        multiplicity_ = 0;
        onChanged();
        return this;
      }

      private int queryIndex_ ;
      /**
       * <code>optional uint32 query_index = 1;</code>
       *
       * <pre>
       * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
       *alignment runs are made with the same set of query sequences, equality of query index means that the query
       *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasQueryIndex() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional uint32 query_index = 1;</code>
       *
       * <pre>
       * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
       *alignment runs are made with the same set of query sequences, equality of query index means that the query
       *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getQueryIndex() {
        return queryIndex_;
      }
      /**
       * <code>optional uint32 query_index = 1;</code>
       *
       * <pre>
       * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
       *alignment runs are made with the same set of query sequences, equality of query index means that the query
       *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setQueryIndex(int value) {
        bitField0_ |= 0x00000002;
        queryIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 query_index = 1;</code>
       *
       * <pre>
       * An integer that uniquely identifies the query (a short read) in a set of alignment runs. When several
       *alignment runs are made with the same set of query sequences, equality of query index means that the query
       *sequences were the same. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearQueryIndex() {
        bitField0_ = (bitField0_ & ~0x00000002);
        queryIndex_ = 0;
        onChanged();
        return this;
      }

      private int targetIndex_ ;
      /**
       * <code>optional uint32 target_index = 2;</code>
       *
       * <pre>
       * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
       *alignment runs are made with the same set of target sequences, equality of target index means that the target
       *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasTargetIndex() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional uint32 target_index = 2;</code>
       *
       * <pre>
       * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
       *alignment runs are made with the same set of target sequences, equality of target index means that the target
       *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getTargetIndex() {
        return targetIndex_;
      }
      /**
       * <code>optional uint32 target_index = 2;</code>
       *
       * <pre>
       * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
       *alignment runs are made with the same set of target sequences, equality of target index means that the target
       *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setTargetIndex(int value) {
        bitField0_ |= 0x00000004;
        targetIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 target_index = 2;</code>
       *
       * <pre>
       * An integer that uniquely identifies the target (e.g., a chromosome) in a set of alignment runs. When several
       *alignment runs are made with the same set of target sequences, equality of target index means that the target
       *sequence was the same across the runs. (Comparing integers for equality is much faster than comparing strings.)
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearTargetIndex() {
        bitField0_ = (bitField0_ & ~0x00000004);
        targetIndex_ = 0;
        onChanged();
        return this;
      }

      private int position_ ;
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position on the target of the start of the alignment between the query and the target.
       *In the following example, position is 3 because the third base of the query 'C' was aligned with
       *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
       *alignment can start at a mismatch if it was so constructed by the aligner.
       *0123456789
       *AAAAGTCAAA  target
       *ctCGTC     query
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasPosition() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position on the target of the start of the alignment between the query and the target.
       *In the following example, position is 3 because the third base of the query 'C' was aligned with
       *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
       *alignment can start at a mismatch if it was so constructed by the aligner.
       *0123456789
       *AAAAGTCAAA  target
       *ctCGTC     query
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getPosition() {
        return position_;
      }
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position on the target of the start of the alignment between the query and the target.
       *In the following example, position is 3 because the third base of the query 'C' was aligned with
       *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
       *alignment can start at a mismatch if it was so constructed by the aligner.
       *0123456789
       *AAAAGTCAAA  target
       *ctCGTC     query
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setPosition(int value) {
        bitField0_ |= 0x00000008;
        position_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position on the target of the start of the alignment between the query and the target.
       *In the following example, position is 3 because the third base of the query 'C' was aligned with
       *position 3 of the reference (two read bases were soft clipped: "ct"). This example shows that the
       *alignment can start at a mismatch if it was so constructed by the aligner.
       *0123456789
       *AAAAGTCAAA  target
       *ctCGTC     query
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearPosition() {
        bitField0_ = (bitField0_ & ~0x00000008);
        position_ = 0;
        onChanged();
        return this;
      }

      private boolean matchingReverseStrand_ ;
      /**
       * <code>optional bool matching_reverse_strand = 6;</code>
       *
       * <pre>
       *True when the query matches the target on the reverse strand
       * </pre>
       */
      public boolean hasMatchingReverseStrand() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional bool matching_reverse_strand = 6;</code>
       *
       * <pre>
       *True when the query matches the target on the reverse strand
       * </pre>
       */
      public boolean getMatchingReverseStrand() {
        return matchingReverseStrand_;
      }
      /**
       * <code>optional bool matching_reverse_strand = 6;</code>
       *
       * <pre>
       *True when the query matches the target on the reverse strand
       * </pre>
       */
      public Builder setMatchingReverseStrand(boolean value) {
        bitField0_ |= 0x00000010;
        matchingReverseStrand_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool matching_reverse_strand = 6;</code>
       *
       * <pre>
       *True when the query matches the target on the reverse strand
       * </pre>
       */
      public Builder clearMatchingReverseStrand() {
        bitField0_ = (bitField0_ & ~0x00000010);
        matchingReverseStrand_ = false;
        onChanged();
        return this;
      }

      private int queryPosition_ ;
      /**
       * <code>optional uint32 query_position = 5;</code>
       *
       * <pre>
       *The position on the query where the alignment starts. This value is different from zero
       *when some bases/residues of the query could not be aligned with the target.
       *TODO: Rename this to left_trim. Add a right_trim property.
       * </pre>
       */
      public boolean hasQueryPosition() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional uint32 query_position = 5;</code>
       *
       * <pre>
       *The position on the query where the alignment starts. This value is different from zero
       *when some bases/residues of the query could not be aligned with the target.
       *TODO: Rename this to left_trim. Add a right_trim property.
       * </pre>
       */
      public int getQueryPosition() {
        return queryPosition_;
      }
      /**
       * <code>optional uint32 query_position = 5;</code>
       *
       * <pre>
       *The position on the query where the alignment starts. This value is different from zero
       *when some bases/residues of the query could not be aligned with the target.
       *TODO: Rename this to left_trim. Add a right_trim property.
       * </pre>
       */
      public Builder setQueryPosition(int value) {
        bitField0_ |= 0x00000020;
        queryPosition_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 query_position = 5;</code>
       *
       * <pre>
       *The position on the query where the alignment starts. This value is different from zero
       *when some bases/residues of the query could not be aligned with the target.
       *TODO: Rename this to left_trim. Add a right_trim property.
       * </pre>
       */
      public Builder clearQueryPosition() {
        bitField0_ = (bitField0_ & ~0x00000020);
        queryPosition_ = 0;
        onChanged();
        return this;
      }

      private float score_ ;
      /**
       * <code>optional float score = 4;</code>
       *
       * <pre>
       *The score of the alignment, where larger scores indicate better matches between the query and the target.
       *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
       *-(#mismatches(query,target)).
       * </pre>
       */
      public boolean hasScore() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional float score = 4;</code>
       *
       * <pre>
       *The score of the alignment, where larger scores indicate better matches between the query and the target.
       *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
       *-(#mismatches(query,target)).
       * </pre>
       */
      public float getScore() {
        return score_;
      }
      /**
       * <code>optional float score = 4;</code>
       *
       * <pre>
       *The score of the alignment, where larger scores indicate better matches between the query and the target.
       *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
       *-(#mismatches(query,target)).
       * </pre>
       */
      public Builder setScore(float value) {
        bitField0_ |= 0x00000040;
        score_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional float score = 4;</code>
       *
       * <pre>
       *The score of the alignment, where larger scores indicate better matches between the query and the target.
       *If an aligner outputs only the number of mismatches between query and target, the score is taken to be
       *-(#mismatches(query,target)).
       * </pre>
       */
      public Builder clearScore() {
        bitField0_ = (bitField0_ & ~0x00000040);
        score_ = 0F;
        onChanged();
        return this;
      }

      private int numberOfMismatches_ ;
      /**
       * <code>optional uint32 number_of_mismatches = 8;</code>
       *
       * <pre>
       *Number of bases/residues that differ in the alignment between query and target sequences.
       * </pre>
       */
      public boolean hasNumberOfMismatches() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <code>optional uint32 number_of_mismatches = 8;</code>
       *
       * <pre>
       *Number of bases/residues that differ in the alignment between query and target sequences.
       * </pre>
       */
      public int getNumberOfMismatches() {
        return numberOfMismatches_;
      }
      /**
       * <code>optional uint32 number_of_mismatches = 8;</code>
       *
       * <pre>
       *Number of bases/residues that differ in the alignment between query and target sequences.
       * </pre>
       */
      public Builder setNumberOfMismatches(int value) {
        bitField0_ |= 0x00000080;
        numberOfMismatches_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 number_of_mismatches = 8;</code>
       *
       * <pre>
       *Number of bases/residues that differ in the alignment between query and target sequences.
       * </pre>
       */
      public Builder clearNumberOfMismatches() {
        bitField0_ = (bitField0_ & ~0x00000080);
        numberOfMismatches_ = 0;
        onChanged();
        return this;
      }

      private int numberOfIndels_ ;
      /**
       * <code>optional uint32 number_of_indels = 9;</code>
       *
       * <pre>
       *Cumulative number of insertions and/or deletions present in the alignment.
       * </pre>
       */
      public boolean hasNumberOfIndels() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional uint32 number_of_indels = 9;</code>
       *
       * <pre>
       *Cumulative number of insertions and/or deletions present in the alignment.
       * </pre>
       */
      public int getNumberOfIndels() {
        return numberOfIndels_;
      }
      /**
       * <code>optional uint32 number_of_indels = 9;</code>
       *
       * <pre>
       *Cumulative number of insertions and/or deletions present in the alignment.
       * </pre>
       */
      public Builder setNumberOfIndels(int value) {
        bitField0_ |= 0x00000100;
        numberOfIndels_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 number_of_indels = 9;</code>
       *
       * <pre>
       *Cumulative number of insertions and/or deletions present in the alignment.
       * </pre>
       */
      public Builder clearNumberOfIndels() {
        bitField0_ = (bitField0_ & ~0x00000100);
        numberOfIndels_ = 0;
        onChanged();
        return this;
      }

      private int queryAlignedLength_ ;
      /**
       * <code>optional uint32 query_aligned_length = 11;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
       *less or equal to query_length.
       * </pre>
       */
      public boolean hasQueryAlignedLength() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional uint32 query_aligned_length = 11;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
       *less or equal to query_length.
       * </pre>
       */
      public int getQueryAlignedLength() {
        return queryAlignedLength_;
      }
      /**
       * <code>optional uint32 query_aligned_length = 11;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
       *less or equal to query_length.
       * </pre>
       */
      public Builder setQueryAlignedLength(int value) {
        bitField0_ |= 0x00000200;
        queryAlignedLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 query_aligned_length = 11;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the query. Please note that query_aligned_length must be
       *less or equal to query_length.
       * </pre>
       */
      public Builder clearQueryAlignedLength() {
        bitField0_ = (bitField0_ & ~0x00000200);
        queryAlignedLength_ = 0;
        onChanged();
        return this;
      }

      private int targetAlignedLength_ ;
      /**
       * <code>optional uint32 target_aligned_length = 12;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the target.
       * </pre>
       */
      public boolean hasTargetAlignedLength() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional uint32 target_aligned_length = 12;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the target.
       * </pre>
       */
      public int getTargetAlignedLength() {
        return targetAlignedLength_;
      }
      /**
       * <code>optional uint32 target_aligned_length = 12;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the target.
       * </pre>
       */
      public Builder setTargetAlignedLength(int value) {
        bitField0_ |= 0x00000400;
        targetAlignedLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 target_aligned_length = 12;</code>
       *
       * <pre>
       *Number of bases that have been aligned for the target.
       * </pre>
       */
      public Builder clearTargetAlignedLength() {
        bitField0_ = (bitField0_ & ~0x00000400);
        targetAlignedLength_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation> sequenceVariations_ =
        java.util.Collections.emptyList();
      private void ensureSequenceVariationsIsMutable() {
        if (!((bitField0_ & 0x00000800) == 0x00000800)) {
          sequenceVariations_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation>(sequenceVariations_);
          bitField0_ |= 0x00000800;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder> sequenceVariationsBuilder_;

      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation> getSequenceVariationsList() {
        if (sequenceVariationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(sequenceVariations_);
        } else {
          return sequenceVariationsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public int getSequenceVariationsCount() {
        if (sequenceVariationsBuilder_ == null) {
          return sequenceVariations_.size();
        } else {
          return sequenceVariationsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation getSequenceVariations(int index) {
        if (sequenceVariationsBuilder_ == null) {
          return sequenceVariations_.get(index);
        } else {
          return sequenceVariationsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder setSequenceVariations(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation value) {
        if (sequenceVariationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSequenceVariationsIsMutable();
          sequenceVariations_.set(index, value);
          onChanged();
        } else {
          sequenceVariationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder setSequenceVariations(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder builderForValue) {
        if (sequenceVariationsBuilder_ == null) {
          ensureSequenceVariationsIsMutable();
          sequenceVariations_.set(index, builderForValue.build());
          onChanged();
        } else {
          sequenceVariationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder addSequenceVariations(edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation value) {
        if (sequenceVariationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSequenceVariationsIsMutable();
          sequenceVariations_.add(value);
          onChanged();
        } else {
          sequenceVariationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder addSequenceVariations(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation value) {
        if (sequenceVariationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSequenceVariationsIsMutable();
          sequenceVariations_.add(index, value);
          onChanged();
        } else {
          sequenceVariationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder addSequenceVariations(
          edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder builderForValue) {
        if (sequenceVariationsBuilder_ == null) {
          ensureSequenceVariationsIsMutable();
          sequenceVariations_.add(builderForValue.build());
          onChanged();
        } else {
          sequenceVariationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder addSequenceVariations(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder builderForValue) {
        if (sequenceVariationsBuilder_ == null) {
          ensureSequenceVariationsIsMutable();
          sequenceVariations_.add(index, builderForValue.build());
          onChanged();
        } else {
          sequenceVariationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder addAllSequenceVariations(
          java.lang.Iterable<? extends edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation> values) {
        if (sequenceVariationsBuilder_ == null) {
          ensureSequenceVariationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, sequenceVariations_);
          onChanged();
        } else {
          sequenceVariationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder clearSequenceVariations() {
        if (sequenceVariationsBuilder_ == null) {
          sequenceVariations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
          onChanged();
        } else {
          sequenceVariationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public Builder removeSequenceVariations(int index) {
        if (sequenceVariationsBuilder_ == null) {
          ensureSequenceVariationsIsMutable();
          sequenceVariations_.remove(index);
          onChanged();
        } else {
          sequenceVariationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder getSequenceVariationsBuilder(
          int index) {
        return getSequenceVariationsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder getSequenceVariationsOrBuilder(
          int index) {
        if (sequenceVariationsBuilder_ == null) {
          return sequenceVariations_.get(index);  } else {
          return sequenceVariationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder> 
           getSequenceVariationsOrBuilderList() {
        if (sequenceVariationsBuilder_ != null) {
          return sequenceVariationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(sequenceVariations_);
        }
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder addSequenceVariationsBuilder() {
        return getSequenceVariationsFieldBuilder().addBuilder(
            edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder addSequenceVariationsBuilder(
          int index) {
        return getSequenceVariationsFieldBuilder().addBuilder(
            index, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.SequenceVariation sequence_variations = 13;</code>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder> 
           getSequenceVariationsBuilderList() {
        return getSequenceVariationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder> 
          getSequenceVariationsFieldBuilder() {
        if (sequenceVariationsBuilder_ == null) {
          sequenceVariationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder>(
                  sequenceVariations_,
                  ((bitField0_ & 0x00000800) == 0x00000800),
                  getParentForChildren(),
                  isClean());
          sequenceVariations_ = null;
        }
        return sequenceVariationsBuilder_;
      }

      private int queryLength_ ;
      /**
       * <code>optional uint32 query_length = 10;</code>
       *
       * <pre>
       *Length of the query sequence.
       * </pre>
       */
      public boolean hasQueryLength() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <code>optional uint32 query_length = 10;</code>
       *
       * <pre>
       *Length of the query sequence.
       * </pre>
       */
      public int getQueryLength() {
        return queryLength_;
      }
      /**
       * <code>optional uint32 query_length = 10;</code>
       *
       * <pre>
       *Length of the query sequence.
       * </pre>
       */
      public Builder setQueryLength(int value) {
        bitField0_ |= 0x00001000;
        queryLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 query_length = 10;</code>
       *
       * <pre>
       *Length of the query sequence.
       * </pre>
       */
      public Builder clearQueryLength() {
        bitField0_ = (bitField0_ & ~0x00001000);
        queryLength_ = 0;
        onChanged();
        return this;
      }

      private int mappingQuality_ ;
      /**
       * <code>optional int32 mapping_quality = 14;</code>
       *
       * <pre>
       *Mapping Quality (phred-scaled posterior probability that the mapping
       *position of this read is incorrect). Please note that different aligners
       *may estimate mapping quality with different approaches, resulting in aligner
       *specific differences in the distribution of mapping quality. It is recommended
       *to condition mapping quality on the aligner that produced the specific alignment
       *being processed. See aligner name and version in the header.
       *Note that the following description is preliminary. A clear specification is
       *needed:
       *The mapping quality should be proportional to the
       *log of the probability that the given mapping is the "correct" one.
       *So if there are five equally good mappings of a read to the genome,
       *the probability of each would be 0.2, and the mapping quality would be
       *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
       *say a 1e-4 of it being wrong, then the mapping quality would be
       *-10*log10(1e-4) = 40.
       * </pre>
       */
      public boolean hasMappingQuality() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <code>optional int32 mapping_quality = 14;</code>
       *
       * <pre>
       *Mapping Quality (phred-scaled posterior probability that the mapping
       *position of this read is incorrect). Please note that different aligners
       *may estimate mapping quality with different approaches, resulting in aligner
       *specific differences in the distribution of mapping quality. It is recommended
       *to condition mapping quality on the aligner that produced the specific alignment
       *being processed. See aligner name and version in the header.
       *Note that the following description is preliminary. A clear specification is
       *needed:
       *The mapping quality should be proportional to the
       *log of the probability that the given mapping is the "correct" one.
       *So if there are five equally good mappings of a read to the genome,
       *the probability of each would be 0.2, and the mapping quality would be
       *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
       *say a 1e-4 of it being wrong, then the mapping quality would be
       *-10*log10(1e-4) = 40.
       * </pre>
       */
      public int getMappingQuality() {
        return mappingQuality_;
      }
      /**
       * <code>optional int32 mapping_quality = 14;</code>
       *
       * <pre>
       *Mapping Quality (phred-scaled posterior probability that the mapping
       *position of this read is incorrect). Please note that different aligners
       *may estimate mapping quality with different approaches, resulting in aligner
       *specific differences in the distribution of mapping quality. It is recommended
       *to condition mapping quality on the aligner that produced the specific alignment
       *being processed. See aligner name and version in the header.
       *Note that the following description is preliminary. A clear specification is
       *needed:
       *The mapping quality should be proportional to the
       *log of the probability that the given mapping is the "correct" one.
       *So if there are five equally good mappings of a read to the genome,
       *the probability of each would be 0.2, and the mapping quality would be
       *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
       *say a 1e-4 of it being wrong, then the mapping quality would be
       *-10*log10(1e-4) = 40.
       * </pre>
       */
      public Builder setMappingQuality(int value) {
        bitField0_ |= 0x00002000;
        mappingQuality_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int32 mapping_quality = 14;</code>
       *
       * <pre>
       *Mapping Quality (phred-scaled posterior probability that the mapping
       *position of this read is incorrect). Please note that different aligners
       *may estimate mapping quality with different approaches, resulting in aligner
       *specific differences in the distribution of mapping quality. It is recommended
       *to condition mapping quality on the aligner that produced the specific alignment
       *being processed. See aligner name and version in the header.
       *Note that the following description is preliminary. A clear specification is
       *needed:
       *The mapping quality should be proportional to the
       *log of the probability that the given mapping is the "correct" one.
       *So if there are five equally good mappings of a read to the genome,
       *the probability of each would be 0.2, and the mapping quality would be
       *something like -10*log10(1-0.2) = 1.  If a mapping is highly likely,
       *say a 1e-4 of it being wrong, then the mapping quality would be
       *-10*log10(1e-4) = 40.
       * </pre>
       */
      public Builder clearMappingQuality() {
        bitField0_ = (bitField0_ & ~0x00002000);
        mappingQuality_ = 0;
        onChanged();
        return this;
      }

      private int pairFlags_ ;
      /**
       * <code>optional uint32 pair_flags = 15;</code>
       *
       * <pre>
       *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
       *000000001    paired
       *000000010    properly paired
       *000000100    read unmapped
       *000001000    mate unmapped
       *000010000    read reverse strand
       *000100000    mate reverse strand
       *001000000    first in pair
       *010000000    second in pair
       *100000000    not primary alignment
       * </pre>
       */
      public boolean hasPairFlags() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <code>optional uint32 pair_flags = 15;</code>
       *
       * <pre>
       *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
       *000000001    paired
       *000000010    properly paired
       *000000100    read unmapped
       *000001000    mate unmapped
       *000010000    read reverse strand
       *000100000    mate reverse strand
       *001000000    first in pair
       *010000000    second in pair
       *100000000    not primary alignment
       * </pre>
       */
      public int getPairFlags() {
        return pairFlags_;
      }
      /**
       * <code>optional uint32 pair_flags = 15;</code>
       *
       * <pre>
       *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
       *000000001    paired
       *000000010    properly paired
       *000000100    read unmapped
       *000001000    mate unmapped
       *000010000    read reverse strand
       *000100000    mate reverse strand
       *001000000    first in pair
       *010000000    second in pair
       *100000000    not primary alignment
       * </pre>
       */
      public Builder setPairFlags(int value) {
        bitField0_ |= 0x00004000;
        pairFlags_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 pair_flags = 15;</code>
       *
       * <pre>
       *If this read was aligned with a pair, the flags for the pair alignment (based on SAM):
       *000000001    paired
       *000000010    properly paired
       *000000100    read unmapped
       *000001000    mate unmapped
       *000010000    read reverse strand
       *000100000    mate reverse strand
       *001000000    first in pair
       *010000000    second in pair
       *100000000    not primary alignment
       * </pre>
       */
      public Builder clearPairFlags() {
        bitField0_ = (bitField0_ & ~0x00004000);
        pairFlags_ = 0;
        onChanged();
        return this;
      }

      private edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry pairAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder> pairAlignmentLinkBuilder_;
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public boolean hasPairAlignmentLink() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getPairAlignmentLink() {
        if (pairAlignmentLinkBuilder_ == null) {
          return pairAlignmentLink_;
        } else {
          return pairAlignmentLinkBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public Builder setPairAlignmentLink(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry value) {
        if (pairAlignmentLinkBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          pairAlignmentLink_ = value;
          onChanged();
        } else {
          pairAlignmentLinkBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00008000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public Builder setPairAlignmentLink(
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder builderForValue) {
        if (pairAlignmentLinkBuilder_ == null) {
          pairAlignmentLink_ = builderForValue.build();
          onChanged();
        } else {
          pairAlignmentLinkBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00008000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public Builder mergePairAlignmentLink(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry value) {
        if (pairAlignmentLinkBuilder_ == null) {
          if (((bitField0_ & 0x00008000) == 0x00008000) &&
              pairAlignmentLink_ != edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance()) {
            pairAlignmentLink_ =
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.newBuilder(pairAlignmentLink_).mergeFrom(value).buildPartial();
          } else {
            pairAlignmentLink_ = value;
          }
          onChanged();
        } else {
          pairAlignmentLinkBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00008000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public Builder clearPairAlignmentLink() {
        if (pairAlignmentLinkBuilder_ == null) {
          pairAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
          onChanged();
        } else {
          pairAlignmentLinkBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00008000);
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder getPairAlignmentLinkBuilder() {
        bitField0_ |= 0x00008000;
        onChanged();
        return getPairAlignmentLinkFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getPairAlignmentLinkOrBuilder() {
        if (pairAlignmentLinkBuilder_ != null) {
          return pairAlignmentLinkBuilder_.getMessageOrBuilder();
        } else {
          return pairAlignmentLink_;
        }
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry pair_alignment_link = 16;</code>
       *
       * <pre>
       *If there is an alignment entry for the paired read (the paired read was mapped), a link to the entry is given.
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder> 
          getPairAlignmentLinkFieldBuilder() {
        if (pairAlignmentLinkBuilder_ == null) {
          pairAlignmentLinkBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder>(
                  getPairAlignmentLink(),
                  getParentForChildren(),
                  isClean());
          pairAlignmentLink_ = null;
        }
        return pairAlignmentLinkBuilder_;
      }

      private int fragmentIndex_ ;
      /**
       * <code>optional uint32 fragment_index = 17;</code>
       *
       * <pre>
       * Index of the read fragment from which this alignment was obtained. 
       * </pre>
       */
      public boolean hasFragmentIndex() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       * <code>optional uint32 fragment_index = 17;</code>
       *
       * <pre>
       * Index of the read fragment from which this alignment was obtained. 
       * </pre>
       */
      public int getFragmentIndex() {
        return fragmentIndex_;
      }
      /**
       * <code>optional uint32 fragment_index = 17;</code>
       *
       * <pre>
       * Index of the read fragment from which this alignment was obtained. 
       * </pre>
       */
      public Builder setFragmentIndex(int value) {
        bitField0_ |= 0x00010000;
        fragmentIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 fragment_index = 17;</code>
       *
       * <pre>
       * Index of the read fragment from which this alignment was obtained. 
       * </pre>
       */
      public Builder clearFragmentIndex() {
        bitField0_ = (bitField0_ & ~0x00010000);
        fragmentIndex_ = 0;
        onChanged();
        return this;
      }

      private edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry splicedForwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder> splicedForwardAlignmentLinkBuilder_;
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public boolean hasSplicedForwardAlignmentLink() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getSplicedForwardAlignmentLink() {
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          return splicedForwardAlignmentLink_;
        } else {
          return splicedForwardAlignmentLinkBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder setSplicedForwardAlignmentLink(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry value) {
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          splicedForwardAlignmentLink_ = value;
          onChanged();
        } else {
          splicedForwardAlignmentLinkBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00020000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder setSplicedForwardAlignmentLink(
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder builderForValue) {
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          splicedForwardAlignmentLink_ = builderForValue.build();
          onChanged();
        } else {
          splicedForwardAlignmentLinkBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00020000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder mergeSplicedForwardAlignmentLink(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry value) {
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          if (((bitField0_ & 0x00020000) == 0x00020000) &&
              splicedForwardAlignmentLink_ != edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance()) {
            splicedForwardAlignmentLink_ =
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.newBuilder(splicedForwardAlignmentLink_).mergeFrom(value).buildPartial();
          } else {
            splicedForwardAlignmentLink_ = value;
          }
          onChanged();
        } else {
          splicedForwardAlignmentLinkBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00020000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder clearSplicedForwardAlignmentLink() {
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          splicedForwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
          onChanged();
        } else {
          splicedForwardAlignmentLinkBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00020000);
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder getSplicedForwardAlignmentLinkBuilder() {
        bitField0_ |= 0x00020000;
        onChanged();
        return getSplicedForwardAlignmentLinkFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getSplicedForwardAlignmentLinkOrBuilder() {
        if (splicedForwardAlignmentLinkBuilder_ != null) {
          return splicedForwardAlignmentLinkBuilder_.getMessageOrBuilder();
        } else {
          return splicedForwardAlignmentLink_;
        }
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_forward_alignment_link = 18;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_forward_alignment_link points to the next
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder> 
          getSplicedForwardAlignmentLinkFieldBuilder() {
        if (splicedForwardAlignmentLinkBuilder_ == null) {
          splicedForwardAlignmentLinkBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder>(
                  getSplicedForwardAlignmentLink(),
                  getParentForChildren(),
                  isClean());
          splicedForwardAlignmentLink_ = null;
        }
        return splicedForwardAlignmentLinkBuilder_;
      }

      private edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry splicedBackwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder> splicedBackwardAlignmentLinkBuilder_;
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public boolean hasSplicedBackwardAlignmentLink() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getSplicedBackwardAlignmentLink() {
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          return splicedBackwardAlignmentLink_;
        } else {
          return splicedBackwardAlignmentLinkBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder setSplicedBackwardAlignmentLink(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry value) {
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          splicedBackwardAlignmentLink_ = value;
          onChanged();
        } else {
          splicedBackwardAlignmentLinkBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00040000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder setSplicedBackwardAlignmentLink(
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder builderForValue) {
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          splicedBackwardAlignmentLink_ = builderForValue.build();
          onChanged();
        } else {
          splicedBackwardAlignmentLinkBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00040000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder mergeSplicedBackwardAlignmentLink(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry value) {
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          if (((bitField0_ & 0x00040000) == 0x00040000) &&
              splicedBackwardAlignmentLink_ != edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance()) {
            splicedBackwardAlignmentLink_ =
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.newBuilder(splicedBackwardAlignmentLink_).mergeFrom(value).buildPartial();
          } else {
            splicedBackwardAlignmentLink_ = value;
          }
          onChanged();
        } else {
          splicedBackwardAlignmentLinkBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00040000;
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public Builder clearSplicedBackwardAlignmentLink() {
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          splicedBackwardAlignmentLink_ = edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
          onChanged();
        } else {
          splicedBackwardAlignmentLinkBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00040000);
        return this;
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder getSplicedBackwardAlignmentLinkBuilder() {
        bitField0_ |= 0x00040000;
        onChanged();
        return getSplicedBackwardAlignmentLinkFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder getSplicedBackwardAlignmentLinkOrBuilder() {
        if (splicedBackwardAlignmentLinkBuilder_ != null) {
          return splicedBackwardAlignmentLinkBuilder_.getMessageOrBuilder();
        } else {
          return splicedBackwardAlignmentLink_;
        }
      }
      /**
       * <code>optional .goby.RelatedAlignmentEntry spliced_backward_alignment_link = 22;</code>
       *
       * <pre>
       * If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two or more
       *alignment entries, one for each matching part of the read, and link these entries with
       *spliced_alignment_links. The field spliced_backward_alignment_link points to the previous
       *AlignmentEntry in the chain of spliced alignments.
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder> 
          getSplicedBackwardAlignmentLinkFieldBuilder() {
        if (splicedBackwardAlignmentLinkBuilder_ == null) {
          splicedBackwardAlignmentLinkBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder>(
                  getSplicedBackwardAlignmentLink(),
                  getParentForChildren(),
                  isClean());
          splicedBackwardAlignmentLink_ = null;
        }
        return splicedBackwardAlignmentLinkBuilder_;
      }

      private int splicedFlags_ ;
      /**
       * <code>optional uint32 spliced_flags = 19;</code>
       *
       * <pre>
       *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
       *matching part of the read, and flag describes the spliced_alignment_link with these
       *binary flags:
       *000000001    normal
       *000000010    novel
       * </pre>
       */
      public boolean hasSplicedFlags() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <code>optional uint32 spliced_flags = 19;</code>
       *
       * <pre>
       *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
       *matching part of the read, and flag describes the spliced_alignment_link with these
       *binary flags:
       *000000001    normal
       *000000010    novel
       * </pre>
       */
      public int getSplicedFlags() {
        return splicedFlags_;
      }
      /**
       * <code>optional uint32 spliced_flags = 19;</code>
       *
       * <pre>
       *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
       *matching part of the read, and flag describes the spliced_alignment_link with these
       *binary flags:
       *000000001    normal
       *000000010    novel
       * </pre>
       */
      public Builder setSplicedFlags(int value) {
        bitField0_ |= 0x00080000;
        splicedFlags_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 spliced_flags = 19;</code>
       *
       * <pre>
       *If a read spans exon-exon junctions some aligners (e.g., GSNAP) will output two alignment entries, one for each
       *matching part of the read, and flag describes the spliced_alignment_link with these
       *binary flags:
       *000000001    normal
       *000000010    novel
       * </pre>
       */
      public Builder clearSplicedFlags() {
        bitField0_ = (bitField0_ & ~0x00080000);
        splicedFlags_ = 0;
        onChanged();
        return this;
      }

      private int insertSize_ ;
      /**
       * <code>optional sint32 insert_size = 20;</code>
       *
       * <pre>
       * The size of the insert used when making the sequence library. This is the total size of the DNA
       *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
       *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
       *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
       * </pre>
       */
      public boolean hasInsertSize() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <code>optional sint32 insert_size = 20;</code>
       *
       * <pre>
       * The size of the insert used when making the sequence library. This is the total size of the DNA
       *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
       *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
       *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
       * </pre>
       */
      public int getInsertSize() {
        return insertSize_;
      }
      /**
       * <code>optional sint32 insert_size = 20;</code>
       *
       * <pre>
       * The size of the insert used when making the sequence library. This is the total size of the DNA
       *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
       *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
       *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
       * </pre>
       */
      public Builder setInsertSize(int value) {
        bitField0_ |= 0x00100000;
        insertSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional sint32 insert_size = 20;</code>
       *
       * <pre>
       * The size of the insert used when making the sequence library. This is the total size of the DNA
       *fragment to sequence, without the adapters. This is not the length of sequence that separates the reads.
       *See http://seqanswers.com/forums/showthread.php?t=8730 for details. Insert size is inferred for each pair
       *of reads by the aligner and is recorded here if was estimated (i.e., for paired-end reads).
       * </pre>
       */
      public Builder clearInsertSize() {
        bitField0_ = (bitField0_ & ~0x00100000);
        insertSize_ = 0;
        onChanged();
        return this;
      }

      private int sampleIndex_ ;
      /**
       * <code>optional uint32 sample_index = 21;</code>
       *
       * <pre>
       *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
       *alignment entry makes it possible to concat alignments from different origins and track what sample originally
       *contained each entry.
       * </pre>
       */
      public boolean hasSampleIndex() {
        return ((bitField0_ & 0x00200000) == 0x00200000);
      }
      /**
       * <code>optional uint32 sample_index = 21;</code>
       *
       * <pre>
       *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
       *alignment entry makes it possible to concat alignments from different origins and track what sample originally
       *contained each entry.
       * </pre>
       */
      public int getSampleIndex() {
        return sampleIndex_;
      }
      /**
       * <code>optional uint32 sample_index = 21;</code>
       *
       * <pre>
       *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
       *alignment entry makes it possible to concat alignments from different origins and track what sample originally
       *contained each entry.
       * </pre>
       */
      public Builder setSampleIndex(int value) {
        bitField0_ |= 0x00200000;
        sampleIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 sample_index = 21;</code>
       *
       * <pre>
       *The sample index. Uniquely identifies the aligned sample this read was read from. Storing the sample index in the
       *alignment entry makes it possible to concat alignments from different origins and track what sample originally
       *contained each entry.
       * </pre>
       */
      public Builder clearSampleIndex() {
        bitField0_ = (bitField0_ & ~0x00200000);
        sampleIndex_ = 0;
        onChanged();
        return this;
      }

      private int queryIndexOccurrences_ ;
      /**
       * <code>optional uint32 query_index_occurrences = 25;</code>
       *
       * <pre>
       *The total number of times the query index associated with this entry occurs across the entire alignment file.
       *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
       *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
       *query_index_occurrences is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasQueryIndexOccurrences() {
        return ((bitField0_ & 0x00400000) == 0x00400000);
      }
      /**
       * <code>optional uint32 query_index_occurrences = 25;</code>
       *
       * <pre>
       *The total number of times the query index associated with this entry occurs across the entire alignment file.
       *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
       *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
       *query_index_occurrences is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getQueryIndexOccurrences() {
        return queryIndexOccurrences_;
      }
      /**
       * <code>optional uint32 query_index_occurrences = 25;</code>
       *
       * <pre>
       *The total number of times the query index associated with this entry occurs across the entire alignment file.
       *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
       *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
       *query_index_occurrences is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setQueryIndexOccurrences(int value) {
        bitField0_ |= 0x00400000;
        queryIndexOccurrences_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 query_index_occurrences = 25;</code>
       *
       * <pre>
       *The total number of times the query index associated with this entry occurs across the entire alignment file.
       *This field is used to purge queryIndex-&gt;smallIndex associations after all instances of a queryindex have
       *been seen (see QueryIndexPermutation class). When each entry has a value for this field, the header field
       *query_index_occurrences is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearQueryIndexOccurrences() {
        bitField0_ = (bitField0_ & ~0x00400000);
        queryIndexOccurrences_ = 0;
        onChanged();
        return this;
      }

      private int ambiguity_ ;
      /**
       * <code>optional uint32 ambiguity = 27;</code>
       *
       * <pre>
       *The total number of times the read matches the reference across the entire alignment file. This differs from
       *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
       *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
       *entries to smaller thresholds). When each entry has a value for this field, the header field
       *ambiguity_stored_in_entries is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasAmbiguity() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       * <code>optional uint32 ambiguity = 27;</code>
       *
       * <pre>
       *The total number of times the read matches the reference across the entire alignment file. This differs from
       *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
       *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
       *entries to smaller thresholds). When each entry has a value for this field, the header field
       *ambiguity_stored_in_entries is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getAmbiguity() {
        return ambiguity_;
      }
      /**
       * <code>optional uint32 ambiguity = 27;</code>
       *
       * <pre>
       *The total number of times the read matches the reference across the entire alignment file. This differs from
       *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
       *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
       *entries to smaller thresholds). When each entry has a value for this field, the header field
       *ambiguity_stored_in_entries is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setAmbiguity(int value) {
        bitField0_ |= 0x00800000;
        ambiguity_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 ambiguity = 27;</code>
       *
       * <pre>
       *The total number of times the read matches the reference across the entire alignment file. This differs from
       *query_index_occurrences because reads that are matching through splice and pair links count as one for ambiguity.
       *The field can be used to filter by ambiguity-threshold on the fly after an alignment has been done (to restrict
       *entries to smaller thresholds). When each entry has a value for this field, the header field
       *ambiguity_stored_in_entries is true.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearAmbiguity() {
        bitField0_ = (bitField0_ & ~0x00800000);
        ambiguity_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList bamAttributes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureBamAttributesIsMutable() {
        if (!((bitField0_ & 0x01000000) == 0x01000000)) {
          bamAttributes_ = new com.google.protobuf.LazyStringArrayList(bamAttributes_);
          bitField0_ |= 0x01000000;
         }
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public com.google.protobuf.ProtocolStringList
          getBamAttributesList() {
        return bamAttributes_.getUnmodifiableView();
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public int getBamAttributesCount() {
        return bamAttributes_.size();
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public java.lang.String getBamAttributes(int index) {
        return bamAttributes_.get(index);
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getBamAttributesBytes(int index) {
        return bamAttributes_.getByteString(index);
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public Builder setBamAttributes(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureBamAttributesIsMutable();
        bamAttributes_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public Builder addBamAttributes(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureBamAttributesIsMutable();
        bamAttributes_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public Builder addAllBamAttributes(
          java.lang.Iterable<java.lang.String> values) {
        ensureBamAttributesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, bamAttributes_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public Builder clearBamAttributes() {
        bamAttributes_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x01000000);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string bam_attributes = 50;</code>
       *
       * <pre>
       *List of BAM attributes, if the alignment was imported from BAM. The attributes are stored in exactly the format
       *allowed for BAM. For instance, X0:i:9  X1:i:1  MD:Z:68 RG:Z:SRR084825 will be stored as four strings:
       *"X0:i:9", "X1:i:1", "MD:Z:68", "RG:Z:SRR084825". Note that sam-to-compact will interpret some BAM attributes
       *and populate goby native fields. Such tags do not appear in bam_attributes, and are instead re-generated from
       *the corresponding goby native fields.
       *Since Goby 2.0.
       * </pre>
       */
      public Builder addBamAttributesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureBamAttributesIsMutable();
        bamAttributes_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString readQualityScores_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes read_quality_scores = 55;</code>
       *
       * <pre>
       *Quality scores for all bases of the read.
       *Since Goby 2.0.
       * </pre>
       */
      public boolean hasReadQualityScores() {
        return ((bitField0_ & 0x02000000) == 0x02000000);
      }
      /**
       * <code>optional bytes read_quality_scores = 55;</code>
       *
       * <pre>
       *Quality scores for all bases of the read.
       *Since Goby 2.0.
       * </pre>
       */
      public com.google.protobuf.ByteString getReadQualityScores() {
        return readQualityScores_;
      }
      /**
       * <code>optional bytes read_quality_scores = 55;</code>
       *
       * <pre>
       *Quality scores for all bases of the read.
       *Since Goby 2.0.
       * </pre>
       */
      public Builder setReadQualityScores(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x02000000;
        readQualityScores_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes read_quality_scores = 55;</code>
       *
       * <pre>
       *Quality scores for all bases of the read.
       *Since Goby 2.0.
       * </pre>
       */
      public Builder clearReadQualityScores() {
        bitField0_ = (bitField0_ & ~0x02000000);
        readQualityScores_ = getDefaultInstance().getReadQualityScores();
        onChanged();
        return this;
      }

      private int readOriginIndex_ ;
      /**
       * <code>optional uint32 read_origin_index = 26;</code>
       *
       * <pre>
       *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
       *makes it possible to track the origin of the read (especially useful after several alignments
       *have been merged/concatenated).
       *(Since Goby 2.0).
       * </pre>
       */
      public boolean hasReadOriginIndex() {
        return ((bitField0_ & 0x04000000) == 0x04000000);
      }
      /**
       * <code>optional uint32 read_origin_index = 26;</code>
       *
       * <pre>
       *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
       *makes it possible to track the origin of the read (especially useful after several alignments
       *have been merged/concatenated).
       *(Since Goby 2.0).
       * </pre>
       */
      public int getReadOriginIndex() {
        return readOriginIndex_;
      }
      /**
       * <code>optional uint32 read_origin_index = 26;</code>
       *
       * <pre>
       *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
       *makes it possible to track the origin of the read (especially useful after several alignments
       *have been merged/concatenated).
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder setReadOriginIndex(int value) {
        bitField0_ |= 0x04000000;
        readOriginIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 read_origin_index = 26;</code>
       *
       * <pre>
       *Origin index. An integer that references a ReadOriginInfo message in the alignment header and
       *makes it possible to track the origin of the read (especially useful after several alignments
       *have been merged/concatenated).
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder clearReadOriginIndex() {
        bitField0_ = (bitField0_ & ~0x04000000);
        readOriginIndex_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object softClippedBasesLeft_ = "";
      /**
       * <code>optional string softClippedBasesLeft = 30;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
       *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
       * </pre>
       */
      public boolean hasSoftClippedBasesLeft() {
        return ((bitField0_ & 0x08000000) == 0x08000000);
      }
      /**
       * <code>optional string softClippedBasesLeft = 30;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
       *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
       * </pre>
       */
      public java.lang.String getSoftClippedBasesLeft() {
        java.lang.Object ref = softClippedBasesLeft_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            softClippedBasesLeft_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string softClippedBasesLeft = 30;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
       *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getSoftClippedBasesLeftBytes() {
        java.lang.Object ref = softClippedBasesLeft_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          softClippedBasesLeft_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string softClippedBasesLeft = 30;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
       *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
       * </pre>
       */
      public Builder setSoftClippedBasesLeft(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x08000000;
        softClippedBasesLeft_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string softClippedBasesLeft = 30;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
       *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
       * </pre>
       */
      public Builder clearSoftClippedBasesLeft() {
        bitField0_ = (bitField0_ & ~0x08000000);
        softClippedBasesLeft_ = getDefaultInstance().getSoftClippedBasesLeft();
        onChanged();
        return this;
      }
      /**
       * <code>optional string softClippedBasesLeft = 30;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Left clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. For instance "A=G" for three soft-clipped bases, the middle one matching the genome at
       *this position. The number of bases in softClippedBasesLeft is exactly equal to queryPosition.
       * </pre>
       */
      public Builder setSoftClippedBasesLeftBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x08000000;
        softClippedBasesLeft_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object softClippedBasesRight_ = "";
      /**
       * <code>optional string softClippedBasesRight = 31;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. The number of bases in softClippedBasesRight is exactly equal
       *to  queryLength - queryAlignedLength - queryPosition.
       * </pre>
       */
      public boolean hasSoftClippedBasesRight() {
        return ((bitField0_ & 0x10000000) == 0x10000000);
      }
      /**
       * <code>optional string softClippedBasesRight = 31;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. The number of bases in softClippedBasesRight is exactly equal
       *to  queryLength - queryAlignedLength - queryPosition.
       * </pre>
       */
      public java.lang.String getSoftClippedBasesRight() {
        java.lang.Object ref = softClippedBasesRight_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            softClippedBasesRight_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string softClippedBasesRight = 31;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. The number of bases in softClippedBasesRight is exactly equal
       *to  queryLength - queryAlignedLength - queryPosition.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getSoftClippedBasesRightBytes() {
        java.lang.Object ref = softClippedBasesRight_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          softClippedBasesRight_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string softClippedBasesRight = 31;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. The number of bases in softClippedBasesRight is exactly equal
       *to  queryLength - queryAlignedLength - queryPosition.
       * </pre>
       */
      public Builder setSoftClippedBasesRight(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x10000000;
        softClippedBasesRight_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string softClippedBasesRight = 31;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. The number of bases in softClippedBasesRight is exactly equal
       *to  queryLength - queryAlignedLength - queryPosition.
       * </pre>
       */
      public Builder clearSoftClippedBasesRight() {
        bitField0_ = (bitField0_ & ~0x10000000);
        softClippedBasesRight_ = getDefaultInstance().getSoftClippedBasesRight();
        onChanged();
        return this;
      }
      /**
       * <code>optional string softClippedBasesRight = 31;</code>
       *
       * <pre>
       *Bases that an aligner considered do not belong to the alignment of the read to the reference. Potentially
       *erroneous bases, or bases that belong to a different part of the reference genome. Right clipped bases are
       *stored in this field as character bases, or as an equal sign character '=' when the clipped base did match
       *the reference base. The number of bases in softClippedBasesRight is exactly equal
       *to  queryLength - queryAlignedLength - queryPosition.
       * </pre>
       */
      public Builder setSoftClippedBasesRightBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x10000000;
        softClippedBasesRight_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString softClippedQualityLeft_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes softClippedQualityLeft = 32;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
       * </pre>
       */
      public boolean hasSoftClippedQualityLeft() {
        return ((bitField0_ & 0x20000000) == 0x20000000);
      }
      /**
       * <code>optional bytes softClippedQualityLeft = 32;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
       * </pre>
       */
      public com.google.protobuf.ByteString getSoftClippedQualityLeft() {
        return softClippedQualityLeft_;
      }
      /**
       * <code>optional bytes softClippedQualityLeft = 32;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
       * </pre>
       */
      public Builder setSoftClippedQualityLeft(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x20000000;
        softClippedQualityLeft_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes softClippedQualityLeft = 32;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesLeft.  Stored in Phred Units.
       * </pre>
       */
      public Builder clearSoftClippedQualityLeft() {
        bitField0_ = (bitField0_ & ~0x20000000);
        softClippedQualityLeft_ = getDefaultInstance().getSoftClippedQualityLeft();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString softClippedQualityRight_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes softClippedQualityRight = 33;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
       * </pre>
       */
      public boolean hasSoftClippedQualityRight() {
        return ((bitField0_ & 0x40000000) == 0x40000000);
      }
      /**
       * <code>optional bytes softClippedQualityRight = 33;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
       * </pre>
       */
      public com.google.protobuf.ByteString getSoftClippedQualityRight() {
        return softClippedQualityRight_;
      }
      /**
       * <code>optional bytes softClippedQualityRight = 33;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
       * </pre>
       */
      public Builder setSoftClippedQualityRight(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x40000000;
        softClippedQualityRight_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes softClippedQualityRight = 33;</code>
       *
       * <pre>
       *Quality scores for bases in softClippedBasesRight.  Stored in Phred Units.
       * </pre>
       */
      public Builder clearSoftClippedQualityRight() {
        bitField0_ = (bitField0_ & ~0x40000000);
        softClippedQualityRight_ = getDefaultInstance().getSoftClippedQualityRight();
        onChanged();
        return this;
      }

      private java.lang.Object placedUnmappedSequence_ = "";
      /**
       * <code>optional string placedUnmappedSequence = 40;</code>
       *
       * <pre>
       *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
       *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
       *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
       *from the reads file.
       * </pre>
       */
      public boolean hasPlacedUnmappedSequence() {
        return ((bitField0_ & 0x80000000) == 0x80000000);
      }
      /**
       * <code>optional string placedUnmappedSequence = 40;</code>
       *
       * <pre>
       *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
       *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
       *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
       *from the reads file.
       * </pre>
       */
      public java.lang.String getPlacedUnmappedSequence() {
        java.lang.Object ref = placedUnmappedSequence_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            placedUnmappedSequence_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string placedUnmappedSequence = 40;</code>
       *
       * <pre>
       *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
       *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
       *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
       *from the reads file.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPlacedUnmappedSequenceBytes() {
        java.lang.Object ref = placedUnmappedSequence_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          placedUnmappedSequence_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string placedUnmappedSequence = 40;</code>
       *
       * <pre>
       *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
       *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
       *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
       *from the reads file.
       * </pre>
       */
      public Builder setPlacedUnmappedSequence(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x80000000;
        placedUnmappedSequence_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string placedUnmappedSequence = 40;</code>
       *
       * <pre>
       *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
       *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
       *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
       *from the reads file.
       * </pre>
       */
      public Builder clearPlacedUnmappedSequence() {
        bitField0_ = (bitField0_ & ~0x80000000);
        placedUnmappedSequence_ = getDefaultInstance().getPlacedUnmappedSequence();
        onChanged();
        return this;
      }
      /**
       * <code>optional string placedUnmappedSequence = 40;</code>
       *
       * <pre>
       *Sequence for a read placed near this entry, but unmapped to the reference sequence. For instance, used to record
       *the sequence of a mate that did not map to the reference. We know that the mate maps in the proximity of this entry
       *(it is placed) but are unable to map it to a specific genomic position. The sequence is always given as obtained
       *from the reads file.
       * </pre>
       */
      public Builder setPlacedUnmappedSequenceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x80000000;
        placedUnmappedSequence_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString placedUnmappedQuality_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes placedUnmappedQuality = 41;</code>
       *
       * <pre>
       *Quality scores for a read placed near this entry.  Phred units.
       * </pre>
       */
      public boolean hasPlacedUnmappedQuality() {
        return ((bitField1_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional bytes placedUnmappedQuality = 41;</code>
       *
       * <pre>
       *Quality scores for a read placed near this entry.  Phred units.
       * </pre>
       */
      public com.google.protobuf.ByteString getPlacedUnmappedQuality() {
        return placedUnmappedQuality_;
      }
      /**
       * <code>optional bytes placedUnmappedQuality = 41;</code>
       *
       * <pre>
       *Quality scores for a read placed near this entry.  Phred units.
       * </pre>
       */
      public Builder setPlacedUnmappedQuality(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField1_ |= 0x00000001;
        placedUnmappedQuality_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes placedUnmappedQuality = 41;</code>
       *
       * <pre>
       *Quality scores for a read placed near this entry.  Phred units.
       * </pre>
       */
      public Builder clearPlacedUnmappedQuality() {
        bitField1_ = (bitField1_ & ~0x00000001);
        placedUnmappedQuality_ = getDefaultInstance().getPlacedUnmappedQuality();
        onChanged();
        return this;
      }

      private java.lang.Object readName_ = "";
      /**
       * <code>optional string readName = 42;</code>
       *
       * <pre>
       *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
       * </pre>
       */
      public boolean hasReadName() {
        return ((bitField1_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional string readName = 42;</code>
       *
       * <pre>
       *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
       * </pre>
       */
      public java.lang.String getReadName() {
        java.lang.Object ref = readName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            readName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string readName = 42;</code>
       *
       * <pre>
       *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getReadNameBytes() {
        java.lang.Object ref = readName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          readName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string readName = 42;</code>
       *
       * <pre>
       *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
       * </pre>
       */
      public Builder setReadName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField1_ |= 0x00000002;
        readName_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string readName = 42;</code>
       *
       * <pre>
       *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
       * </pre>
       */
      public Builder clearReadName() {
        bitField1_ = (bitField1_ & ~0x00000002);
        readName_ = getDefaultInstance().getReadName();
        onChanged();
        return this;
      }
      /**
       * <code>optional string readName = 42;</code>
       *
       * <pre>
       *Read name. In SAM/BAM this is referred to as QNAME. Paired and segmented reads will have the same Read name.
       * </pre>
       */
      public Builder setReadNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField1_ |= 0x00000002;
        readName_ = value;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:goby.AlignmentEntry)
    }

    static {
      defaultInstance = new AlignmentEntry(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.AlignmentEntry)
  }

  public interface RelatedAlignmentEntryOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.RelatedAlignmentEntry)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint32 target_index = 1;</code>
     *
     * <pre>
     * Target index of the location where the other alignment entry is mapped.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasTargetIndex();
    /**
     * <code>optional uint32 target_index = 1;</code>
     *
     * <pre>
     * Target index of the location where the other alignment entry is mapped.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getTargetIndex();

    /**
     * <code>optional uint32 position = 2;</code>
     *
     * <pre>
     * Position on the reference where the other alignment entry is mapped. *
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasPosition();
    /**
     * <code>optional uint32 position = 2;</code>
     *
     * <pre>
     * Position on the reference where the other alignment entry is mapped. *
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getPosition();

    /**
     * <code>optional uint32 fragment_index = 3;</code>
     *
     * <pre>
     * Index of the fragment for the related alignment entry. This index
     *makes it possible to identify which of the read fragments mapped to the given
     *location is related to the source alignment entry.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasFragmentIndex();
    /**
     * <code>optional uint32 fragment_index = 3;</code>
     *
     * <pre>
     * Index of the fragment for the related alignment entry. This index
     *makes it possible to identify which of the read fragments mapped to the given
     *location is related to the source alignment entry.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getFragmentIndex();

    /**
     * <code>optional uint32 optimized_index = 50;</code>
     */
    boolean hasOptimizedIndex();
    /**
     * <code>optional uint32 optimized_index = 50;</code>
     */
    int getOptimizedIndex();
  }
  /**
   * Protobuf type {@code goby.RelatedAlignmentEntry}
   *
   * <pre>
   * A link to another alignment entry. This message type is used to represent relations
   *between alignments, such as the relation between the two read fragments in a paired-end protocol,
   *or the relation between parts of reads that align through an exon exon junction and map in
   *different locations of the genome.
   * </pre>
   */
  public static final class RelatedAlignmentEntry extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.RelatedAlignmentEntry)
      RelatedAlignmentEntryOrBuilder {
    // Use RelatedAlignmentEntry.newBuilder() to construct.
    private RelatedAlignmentEntry(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private RelatedAlignmentEntry(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final RelatedAlignmentEntry defaultInstance;
    public static RelatedAlignmentEntry getDefaultInstance() {
      return defaultInstance;
    }

    public RelatedAlignmentEntry getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private RelatedAlignmentEntry(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000001;
              targetIndex_ = input.readUInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              position_ = input.readUInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              fragmentIndex_ = input.readUInt32();
              break;
            }
            case 400: {
              bitField0_ |= 0x00000008;
              optimizedIndex_ = input.readUInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_RelatedAlignmentEntry_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_RelatedAlignmentEntry_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.class, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder.class);
    }

    public static com.google.protobuf.Parser<RelatedAlignmentEntry> PARSER =
        new com.google.protobuf.AbstractParser<RelatedAlignmentEntry>() {
      public RelatedAlignmentEntry parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RelatedAlignmentEntry(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<RelatedAlignmentEntry> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int TARGET_INDEX_FIELD_NUMBER = 1;
    private int targetIndex_;
    /**
     * <code>optional uint32 target_index = 1;</code>
     *
     * <pre>
     * Target index of the location where the other alignment entry is mapped.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasTargetIndex() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional uint32 target_index = 1;</code>
     *
     * <pre>
     * Target index of the location where the other alignment entry is mapped.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getTargetIndex() {
      return targetIndex_;
    }

    public static final int POSITION_FIELD_NUMBER = 2;
    private int position_;
    /**
     * <code>optional uint32 position = 2;</code>
     *
     * <pre>
     * Position on the reference where the other alignment entry is mapped. *
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasPosition() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional uint32 position = 2;</code>
     *
     * <pre>
     * Position on the reference where the other alignment entry is mapped. *
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getPosition() {
      return position_;
    }

    public static final int FRAGMENT_INDEX_FIELD_NUMBER = 3;
    private int fragmentIndex_;
    /**
     * <code>optional uint32 fragment_index = 3;</code>
     *
     * <pre>
     * Index of the fragment for the related alignment entry. This index
     *makes it possible to identify which of the read fragments mapped to the given
     *location is related to the source alignment entry.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasFragmentIndex() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional uint32 fragment_index = 3;</code>
     *
     * <pre>
     * Index of the fragment for the related alignment entry. This index
     *makes it possible to identify which of the read fragments mapped to the given
     *location is related to the source alignment entry.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getFragmentIndex() {
      return fragmentIndex_;
    }

    public static final int OPTIMIZED_INDEX_FIELD_NUMBER = 50;
    private int optimizedIndex_;
    /**
     * <code>optional uint32 optimized_index = 50;</code>
     */
    public boolean hasOptimizedIndex() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional uint32 optimized_index = 50;</code>
     */
    public int getOptimizedIndex() {
      return optimizedIndex_;
    }

    private void initFields() {
      targetIndex_ = 0;
      position_ = 0;
      fragmentIndex_ = 0;
      optimizedIndex_ = 0;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(1, targetIndex_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(2, position_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt32(3, fragmentIndex_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt32(50, optimizedIndex_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, targetIndex_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, position_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, fragmentIndex_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(50, optimizedIndex_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.RelatedAlignmentEntry}
     *
     * <pre>
     * A link to another alignment entry. This message type is used to represent relations
     *between alignments, such as the relation between the two read fragments in a paired-end protocol,
     *or the relation between parts of reads that align through an exon exon junction and map in
     *different locations of the genome.
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.RelatedAlignmentEntry)
        edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntryOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_RelatedAlignmentEntry_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_RelatedAlignmentEntry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.class, edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        targetIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        position_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        fragmentIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        optimizedIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_RelatedAlignmentEntry_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry build() {
        edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry result = new edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.targetIndex_ = targetIndex_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.position_ = position_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.fragmentIndex_ = fragmentIndex_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.optimizedIndex_ = optimizedIndex_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry.getDefaultInstance()) return this;
        if (other.hasTargetIndex()) {
          setTargetIndex(other.getTargetIndex());
        }
        if (other.hasPosition()) {
          setPosition(other.getPosition());
        }
        if (other.hasFragmentIndex()) {
          setFragmentIndex(other.getFragmentIndex());
        }
        if (other.hasOptimizedIndex()) {
          setOptimizedIndex(other.getOptimizedIndex());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.RelatedAlignmentEntry) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int targetIndex_ ;
      /**
       * <code>optional uint32 target_index = 1;</code>
       *
       * <pre>
       * Target index of the location where the other alignment entry is mapped.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasTargetIndex() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional uint32 target_index = 1;</code>
       *
       * <pre>
       * Target index of the location where the other alignment entry is mapped.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getTargetIndex() {
        return targetIndex_;
      }
      /**
       * <code>optional uint32 target_index = 1;</code>
       *
       * <pre>
       * Target index of the location where the other alignment entry is mapped.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setTargetIndex(int value) {
        bitField0_ |= 0x00000001;
        targetIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 target_index = 1;</code>
       *
       * <pre>
       * Target index of the location where the other alignment entry is mapped.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearTargetIndex() {
        bitField0_ = (bitField0_ & ~0x00000001);
        targetIndex_ = 0;
        onChanged();
        return this;
      }

      private int position_ ;
      /**
       * <code>optional uint32 position = 2;</code>
       *
       * <pre>
       * Position on the reference where the other alignment entry is mapped. *
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasPosition() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional uint32 position = 2;</code>
       *
       * <pre>
       * Position on the reference where the other alignment entry is mapped. *
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getPosition() {
        return position_;
      }
      /**
       * <code>optional uint32 position = 2;</code>
       *
       * <pre>
       * Position on the reference where the other alignment entry is mapped. *
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setPosition(int value) {
        bitField0_ |= 0x00000002;
        position_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 position = 2;</code>
       *
       * <pre>
       * Position on the reference where the other alignment entry is mapped. *
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearPosition() {
        bitField0_ = (bitField0_ & ~0x00000002);
        position_ = 0;
        onChanged();
        return this;
      }

      private int fragmentIndex_ ;
      /**
       * <code>optional uint32 fragment_index = 3;</code>
       *
       * <pre>
       * Index of the fragment for the related alignment entry. This index
       *makes it possible to identify which of the read fragments mapped to the given
       *location is related to the source alignment entry.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasFragmentIndex() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional uint32 fragment_index = 3;</code>
       *
       * <pre>
       * Index of the fragment for the related alignment entry. This index
       *makes it possible to identify which of the read fragments mapped to the given
       *location is related to the source alignment entry.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getFragmentIndex() {
        return fragmentIndex_;
      }
      /**
       * <code>optional uint32 fragment_index = 3;</code>
       *
       * <pre>
       * Index of the fragment for the related alignment entry. This index
       *makes it possible to identify which of the read fragments mapped to the given
       *location is related to the source alignment entry.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setFragmentIndex(int value) {
        bitField0_ |= 0x00000004;
        fragmentIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 fragment_index = 3;</code>
       *
       * <pre>
       * Index of the fragment for the related alignment entry. This index
       *makes it possible to identify which of the read fragments mapped to the given
       *location is related to the source alignment entry.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearFragmentIndex() {
        bitField0_ = (bitField0_ & ~0x00000004);
        fragmentIndex_ = 0;
        onChanged();
        return this;
      }

      private int optimizedIndex_ ;
      /**
       * <code>optional uint32 optimized_index = 50;</code>
       */
      public boolean hasOptimizedIndex() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional uint32 optimized_index = 50;</code>
       */
      public int getOptimizedIndex() {
        return optimizedIndex_;
      }
      /**
       * <code>optional uint32 optimized_index = 50;</code>
       */
      public Builder setOptimizedIndex(int value) {
        bitField0_ |= 0x00000008;
        optimizedIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 optimized_index = 50;</code>
       */
      public Builder clearOptimizedIndex() {
        bitField0_ = (bitField0_ & ~0x00000008);
        optimizedIndex_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:goby.RelatedAlignmentEntry)
    }

    static {
      defaultInstance = new RelatedAlignmentEntry(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.RelatedAlignmentEntry)
  }

  public interface SequenceVariationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.SequenceVariation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string from = 2;</code>
     *
     * <pre>
     * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
     *no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasFrom();
    /**
     * <code>optional string from = 2;</code>
     *
     * <pre>
     * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
     *no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    java.lang.String getFrom();
    /**
     * <code>optional string from = 2;</code>
     *
     * <pre>
     * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
     *no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    com.google.protobuf.ByteString
        getFromBytes();

    /**
     * <code>optional string to = 1;</code>
     *
     * <pre>
     * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
     *that the query sequence has no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasTo();
    /**
     * <code>optional string to = 1;</code>
     *
     * <pre>
     * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
     *that the query sequence has no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    java.lang.String getTo();
    /**
     * <code>optional string to = 1;</code>
     *
     * <pre>
     * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
     *that the query sequence has no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    com.google.protobuf.ByteString
        getToBytes();

    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position of the variation on the read, as if the read always matched on the forward strand.
     *Adding position to the index where the reference starts aligning the read yields the position of the variation
     *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasPosition();
    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position of the variation on the read, as if the read always matched on the forward strand.
     *Adding position to the index where the reference starts aligning the read yields the position of the variation
     *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getPosition();

    /**
     * <code>optional uint32 read_index = 5;</code>
     *
     * <pre>
     *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
     *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
     *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
     *where the bases are inserted (these bases are in the to field).
     *When the read has a deletion, read_index records the position in the read after which the bases that would align
     *in the reference are missing (these bases are in the from field).
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    boolean hasReadIndex();
    /**
     * <code>optional uint32 read_index = 5;</code>
     *
     * <pre>
     *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
     *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
     *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
     *where the bases are inserted (these bases are in the to field).
     *When the read has a deletion, read_index records the position in the read after which the bases that would align
     *in the reference are missing (these bases are in the from field).
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    int getReadIndex();

    /**
     * <code>optional bytes to_quality = 4;</code>
     *
     * <pre>
     **
     *The read base quality scores for those bases that are given in the to field. This field
     *is populated when the reads used to perform the search include quality scores, and when
     *the alignment parser can extract the information from the aligner's output.
     *(this option is currently not implemented in Goby.)
     * </pre>
     */
    boolean hasToQuality();
    /**
     * <code>optional bytes to_quality = 4;</code>
     *
     * <pre>
     **
     *The read base quality scores for those bases that are given in the to field. This field
     *is populated when the reads used to perform the search include quality scores, and when
     *the alignment parser can extract the information from the aligner's output.
     *(this option is currently not implemented in Goby.)
     * </pre>
     */
    com.google.protobuf.ByteString getToQuality();
  }
  /**
   * Protobuf type {@code goby.SequenceVariation}
   *
   * <pre>
   *Represents sequence variations between the query and the reference sequences. Many variations can be represented.
   *For instance, an insertion at position 5 in the reference would be represented as from="A", to="" position=5.
   *A mutation T-&gt;G at position 6 would be rendered as from="T", to="G" position=6. Padded alignments (see SAM description)
   *can be described by a combination of pair-wise alignments, where the gap character '-' is used to indicate that no
   *base exists in the sequence considered for the alignment position, for instance:
   *- Padding example:
   *123 (&lt;-positions)
   *ref A-C
   *A-T [from="-" to=""  position=2] [from="C" to="T"  position=3]
   *ACT [from=""  to="C" position=2] [from="C" to="T"  position=3]
   *A-T [from="-" to=""  position=2] [from="C" to="T"  position=3]
   *- Mutation example:
   *123 (&lt;-positions)
   *ref ATT
   *ACT [from="T"  to="C" position=2]
   *-- Example of deletion in a read:
   *123 (&lt;-positions)
   *ref ATT
   *A-T [from="T"  to="-" position=2]
   *-- Example of insertion of two base pairs in a read:
   *12345 (&lt;-positions)
   *ref A--TT
   *ACCTT [from=""  to="CC" position=2]
   * </pre>
   */
  public static final class SequenceVariation extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.SequenceVariation)
      SequenceVariationOrBuilder {
    // Use SequenceVariation.newBuilder() to construct.
    private SequenceVariation(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private SequenceVariation(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final SequenceVariation defaultInstance;
    public static SequenceVariation getDefaultInstance() {
      return defaultInstance;
    }

    public SequenceVariation getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private SequenceVariation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              to_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              from_ = bs;
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              position_ = input.readUInt32();
              break;
            }
            case 34: {
              bitField0_ |= 0x00000010;
              toQuality_ = input.readBytes();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000008;
              readIndex_ = input.readUInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_SequenceVariation_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_SequenceVariation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.class, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder.class);
    }

    public static com.google.protobuf.Parser<SequenceVariation> PARSER =
        new com.google.protobuf.AbstractParser<SequenceVariation>() {
      public SequenceVariation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SequenceVariation(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<SequenceVariation> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int FROM_FIELD_NUMBER = 2;
    private java.lang.Object from_;
    /**
     * <code>optional string from = 2;</code>
     *
     * <pre>
     * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
     *no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasFrom() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional string from = 2;</code>
     *
     * <pre>
     * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
     *no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public java.lang.String getFrom() {
      java.lang.Object ref = from_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          from_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string from = 2;</code>
     *
     * <pre>
     * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
     *no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public com.google.protobuf.ByteString
        getFromBytes() {
      java.lang.Object ref = from_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        from_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TO_FIELD_NUMBER = 1;
    private java.lang.Object to_;
    /**
     * <code>optional string to = 1;</code>
     *
     * <pre>
     * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
     *that the query sequence has no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasTo() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional string to = 1;</code>
     *
     * <pre>
     * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
     *that the query sequence has no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public java.lang.String getTo() {
      java.lang.Object ref = to_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          to_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string to = 1;</code>
     *
     * <pre>
     * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
     *that the query sequence has no base at this alignment position.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public com.google.protobuf.ByteString
        getToBytes() {
      java.lang.Object ref = to_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        to_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int POSITION_FIELD_NUMBER = 3;
    private int position_;
    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position of the variation on the read, as if the read always matched on the forward strand.
     *Adding position to the index where the reference starts aligning the read yields the position of the variation
     *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasPosition() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional uint32 position = 3;</code>
     *
     * <pre>
     *The position of the variation on the read, as if the read always matched on the forward strand.
     *Adding position to the index where the reference starts aligning the read yields the position of the variation
     *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getPosition() {
      return position_;
    }

    public static final int READ_INDEX_FIELD_NUMBER = 5;
    private int readIndex_;
    /**
     * <code>optional uint32 read_index = 5;</code>
     *
     * <pre>
     *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
     *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
     *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
     *where the bases are inserted (these bases are in the to field).
     *When the read has a deletion, read_index records the position in the read after which the bases that would align
     *in the reference are missing (these bases are in the from field).
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public boolean hasReadIndex() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional uint32 read_index = 5;</code>
     *
     * <pre>
     *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
     *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
     *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
     *where the bases are inserted (these bases are in the to field).
     *When the read has a deletion, read_index records the position in the read after which the bases that would align
     *in the reference are missing (these bases are in the from field).
     *This field is required (enforced by semantic validation in Goby 2.0+).
     * </pre>
     */
    public int getReadIndex() {
      return readIndex_;
    }

    public static final int TO_QUALITY_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString toQuality_;
    /**
     * <code>optional bytes to_quality = 4;</code>
     *
     * <pre>
     **
     *The read base quality scores for those bases that are given in the to field. This field
     *is populated when the reads used to perform the search include quality scores, and when
     *the alignment parser can extract the information from the aligner's output.
     *(this option is currently not implemented in Goby.)
     * </pre>
     */
    public boolean hasToQuality() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional bytes to_quality = 4;</code>
     *
     * <pre>
     **
     *The read base quality scores for those bases that are given in the to field. This field
     *is populated when the reads used to perform the search include quality scores, and when
     *the alignment parser can extract the information from the aligner's output.
     *(this option is currently not implemented in Goby.)
     * </pre>
     */
    public com.google.protobuf.ByteString getToQuality() {
      return toQuality_;
    }

    private void initFields() {
      from_ = "";
      to_ = "";
      position_ = 0;
      readIndex_ = 0;
      toQuality_ = com.google.protobuf.ByteString.EMPTY;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(1, getToBytes());
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(2, getFromBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt32(3, position_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBytes(4, toQuality_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt32(5, readIndex_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, getToBytes());
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, getFromBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, position_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, toQuality_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, readIndex_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.SequenceVariation}
     *
     * <pre>
     *Represents sequence variations between the query and the reference sequences. Many variations can be represented.
     *For instance, an insertion at position 5 in the reference would be represented as from="A", to="" position=5.
     *A mutation T-&gt;G at position 6 would be rendered as from="T", to="G" position=6. Padded alignments (see SAM description)
     *can be described by a combination of pair-wise alignments, where the gap character '-' is used to indicate that no
     *base exists in the sequence considered for the alignment position, for instance:
     *- Padding example:
     *123 (&lt;-positions)
     *ref A-C
     *A-T [from="-" to=""  position=2] [from="C" to="T"  position=3]
     *ACT [from=""  to="C" position=2] [from="C" to="T"  position=3]
     *A-T [from="-" to=""  position=2] [from="C" to="T"  position=3]
     *- Mutation example:
     *123 (&lt;-positions)
     *ref ATT
     *ACT [from="T"  to="C" position=2]
     *-- Example of deletion in a read:
     *123 (&lt;-positions)
     *ref ATT
     *A-T [from="T"  to="-" position=2]
     *-- Example of insertion of two base pairs in a read:
     *12345 (&lt;-positions)
     *ref A--TT
     *ACCTT [from=""  to="CC" position=2]
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.SequenceVariation)
        edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_SequenceVariation_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_SequenceVariation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.class, edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        from_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        to_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        position_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        readIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        toQuality_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_SequenceVariation_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation build() {
        edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation result = new edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.from_ = from_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.to_ = to_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.position_ = position_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.readIndex_ = readIndex_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.toQuality_ = toQuality_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation.getDefaultInstance()) return this;
        if (other.hasFrom()) {
          bitField0_ |= 0x00000001;
          from_ = other.from_;
          onChanged();
        }
        if (other.hasTo()) {
          bitField0_ |= 0x00000002;
          to_ = other.to_;
          onChanged();
        }
        if (other.hasPosition()) {
          setPosition(other.getPosition());
        }
        if (other.hasReadIndex()) {
          setReadIndex(other.getReadIndex());
        }
        if (other.hasToQuality()) {
          setToQuality(other.getToQuality());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.SequenceVariation) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object from_ = "";
      /**
       * <code>optional string from = 2;</code>
       *
       * <pre>
       * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
       *no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasFrom() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional string from = 2;</code>
       *
       * <pre>
       * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
       *no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public java.lang.String getFrom() {
        java.lang.Object ref = from_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            from_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string from = 2;</code>
       *
       * <pre>
       * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
       *no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public com.google.protobuf.ByteString
          getFromBytes() {
        java.lang.Object ref = from_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          from_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string from = 2;</code>
       *
       * <pre>
       * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
       *no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setFrom(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        from_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string from = 2;</code>
       *
       * <pre>
       * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
       *no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearFrom() {
        bitField0_ = (bitField0_ & ~0x00000001);
        from_ = getDefaultInstance().getFrom();
        onChanged();
        return this;
      }
      /**
       * <code>optional string from = 2;</code>
       *
       * <pre>
       * The reference bases. Can include one or more gap characters '-', to indicate that the reference sequence has
       *no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setFromBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        from_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object to_ = "";
      /**
       * <code>optional string to = 1;</code>
       *
       * <pre>
       * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
       *that the query sequence has no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasTo() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional string to = 1;</code>
       *
       * <pre>
       * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
       *that the query sequence has no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public java.lang.String getTo() {
        java.lang.Object ref = to_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            to_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string to = 1;</code>
       *
       * <pre>
       * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
       *that the query sequence has no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public com.google.protobuf.ByteString
          getToBytes() {
        java.lang.Object ref = to_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          to_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string to = 1;</code>
       *
       * <pre>
       * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
       *that the query sequence has no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setTo(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        to_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string to = 1;</code>
       *
       * <pre>
       * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
       *that the query sequence has no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearTo() {
        bitField0_ = (bitField0_ & ~0x00000002);
        to_ = getDefaultInstance().getTo();
        onChanged();
        return this;
      }
      /**
       * <code>optional string to = 1;</code>
       *
       * <pre>
       * The read bases that differ from the reference sequence.  Can include one or more gap characters '-', to indicate
       *that the query sequence has no base at this alignment position.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setToBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        to_ = value;
        onChanged();
        return this;
      }

      private int position_ ;
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position of the variation on the read, as if the read always matched on the forward strand.
       *Adding position to the index where the reference starts aligning the read yields the position of the variation
       *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasPosition() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position of the variation on the read, as if the read always matched on the forward strand.
       *Adding position to the index where the reference starts aligning the read yields the position of the variation
       *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getPosition() {
        return position_;
      }
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position of the variation on the read, as if the read always matched on the forward strand.
       *Adding position to the index where the reference starts aligning the read yields the position of the variation
       *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setPosition(int value) {
        bitField0_ |= 0x00000004;
        position_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 position = 3;</code>
       *
       * <pre>
       *The position of the variation on the read, as if the read always matched on the forward strand.
       *Adding position to the index where the reference starts aligning the read yields the position of the variation
       *in reference/target sequence space. Since position starts at one the resulting position will also be one based.
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearPosition() {
        bitField0_ = (bitField0_ & ~0x00000004);
        position_ = 0;
        onChanged();
        return this;
      }

      private int readIndex_ ;
      /**
       * <code>optional uint32 read_index = 5;</code>
       *
       * <pre>
       *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
       *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
       *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
       *where the bases are inserted (these bases are in the to field).
       *When the read has a deletion, read_index records the position in the read after which the bases that would align
       *in the reference are missing (these bases are in the from field).
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public boolean hasReadIndex() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional uint32 read_index = 5;</code>
       *
       * <pre>
       *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
       *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
       *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
       *where the bases are inserted (these bases are in the to field).
       *When the read has a deletion, read_index records the position in the read after which the bases that would align
       *in the reference are missing (these bases are in the from field).
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public int getReadIndex() {
        return readIndex_;
      }
      /**
       * <code>optional uint32 read_index = 5;</code>
       *
       * <pre>
       *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
       *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
       *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
       *where the bases are inserted (these bases are in the to field).
       *When the read has a deletion, read_index records the position in the read after which the bases that would align
       *in the reference are missing (these bases are in the from field).
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder setReadIndex(int value) {
        bitField0_ |= 0x00000008;
        readIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 read_index = 5;</code>
       *
       * <pre>
       *The position of the variation, starting from the beginning of the aligned read (position 1), and up to the length
       *of the read (inclusive). Use this index if you need to know  how far the variation is observed from the beginning
       *of the sequenced read. When the read has an insertion, this index records the position immediately before the base
       *where the bases are inserted (these bases are in the to field).
       *When the read has a deletion, read_index records the position in the read after which the bases that would align
       *in the reference are missing (these bases are in the from field).
       *This field is required (enforced by semantic validation in Goby 2.0+).
       * </pre>
       */
      public Builder clearReadIndex() {
        bitField0_ = (bitField0_ & ~0x00000008);
        readIndex_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString toQuality_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes to_quality = 4;</code>
       *
       * <pre>
       **
       *The read base quality scores for those bases that are given in the to field. This field
       *is populated when the reads used to perform the search include quality scores, and when
       *the alignment parser can extract the information from the aligner's output.
       *(this option is currently not implemented in Goby.)
       * </pre>
       */
      public boolean hasToQuality() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional bytes to_quality = 4;</code>
       *
       * <pre>
       **
       *The read base quality scores for those bases that are given in the to field. This field
       *is populated when the reads used to perform the search include quality scores, and when
       *the alignment parser can extract the information from the aligner's output.
       *(this option is currently not implemented in Goby.)
       * </pre>
       */
      public com.google.protobuf.ByteString getToQuality() {
        return toQuality_;
      }
      /**
       * <code>optional bytes to_quality = 4;</code>
       *
       * <pre>
       **
       *The read base quality scores for those bases that are given in the to field. This field
       *is populated when the reads used to perform the search include quality scores, and when
       *the alignment parser can extract the information from the aligner's output.
       *(this option is currently not implemented in Goby.)
       * </pre>
       */
      public Builder setToQuality(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        toQuality_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes to_quality = 4;</code>
       *
       * <pre>
       **
       *The read base quality scores for those bases that are given in the to field. This field
       *is populated when the reads used to perform the search include quality scores, and when
       *the alignment parser can extract the information from the aligner's output.
       *(this option is currently not implemented in Goby.)
       * </pre>
       */
      public Builder clearToQuality() {
        bitField0_ = (bitField0_ & ~0x00000010);
        toQuality_ = getDefaultInstance().getToQuality();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:goby.SequenceVariation)
    }

    static {
      defaultInstance = new SequenceVariation(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.SequenceVariation)
  }

  public interface AlignmentHeaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.AlignmentHeader)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint32 smallest_split_query_index = 9;</code>
     *
     * <pre>
     *The smallest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    boolean hasSmallestSplitQueryIndex();
    /**
     * <code>optional uint32 smallest_split_query_index = 9;</code>
     *
     * <pre>
     *The smallest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    int getSmallestSplitQueryIndex();

    /**
     * <code>optional uint32 largest_split_query_index = 11;</code>
     *
     * <pre>
     *The largest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    boolean hasLargestSplitQueryIndex();
    /**
     * <code>optional uint32 largest_split_query_index = 11;</code>
     *
     * <pre>
     *The largest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    int getLargestSplitQueryIndex();

    /**
     * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
     *
     * <pre>
     * Mapping from query identifier name to query index (as used in alignment entries).
     * </pre>
     */
    boolean hasQueryNameMapping();
    /**
     * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
     *
     * <pre>
     * Mapping from query identifier name to query index (as used in alignment entries).
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping getQueryNameMapping();
    /**
     * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
     *
     * <pre>
     * Mapping from query identifier name to query index (as used in alignment entries).
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder getQueryNameMappingOrBuilder();

    /**
     * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
     *
     * <pre>
     * Mapping from target identifier name to target index (as used in alignment entries).
     * </pre>
     */
    boolean hasTargetNameMapping();
    /**
     * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
     *
     * <pre>
     * Mapping from target identifier name to target index (as used in alignment entries).
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping getTargetNameMapping();
    /**
     * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
     *
     * <pre>
     * Mapping from target identifier name to target index (as used in alignment entries).
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder getTargetNameMappingOrBuilder();

    /**
     * <code>optional uint32 number_of_queries = 5;</code>
     *
     * <pre>
     *The number of query sequences
     * </pre>
     */
    boolean hasNumberOfQueries();
    /**
     * <code>optional uint32 number_of_queries = 5;</code>
     *
     * <pre>
     *The number of query sequences
     * </pre>
     */
    int getNumberOfQueries();

    /**
     * <code>optional uint32 number_of_targets = 6;</code>
     *
     * <pre>
     *The number of target sequences
     * </pre>
     */
    boolean hasNumberOfTargets();
    /**
     * <code>optional uint32 number_of_targets = 6;</code>
     *
     * <pre>
     *The number of target sequences
     * </pre>
     */
    int getNumberOfTargets();

    /**
     * <code>optional uint32 number_of_aligned_reads = 7;</code>
     *
     * <pre>
     *The number of reads that were aligned to the reference and are represented in this alignment archive.
     * </pre>
     */
    boolean hasNumberOfAlignedReads();
    /**
     * <code>optional uint32 number_of_aligned_reads = 7;</code>
     *
     * <pre>
     *The number of reads that were aligned to the reference and are represented in this alignment archive.
     * </pre>
     */
    int getNumberOfAlignedReads();

    /**
     * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
     *
     * <pre>
     *Length of the query sequences. One number per query, in the order of increasing query index.
     *This information has been moved to the individual alignment entries.
     * </pre>
     */
    @java.lang.Deprecated java.util.List<java.lang.Integer> getQueryLengthList();
    /**
     * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
     *
     * <pre>
     *Length of the query sequences. One number per query, in the order of increasing query index.
     *This information has been moved to the individual alignment entries.
     * </pre>
     */
    @java.lang.Deprecated int getQueryLengthCount();
    /**
     * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
     *
     * <pre>
     *Length of the query sequences. One number per query, in the order of increasing query index.
     *This information has been moved to the individual alignment entries.
     * </pre>
     */
    @java.lang.Deprecated int getQueryLength(int index);

    /**
     * <code>optional uint32 constant_query_length = 10;</code>
     *
     * <pre>
     *If query length is constant across all the queries, this field contains the constant length.
     *In such cases, query_length will be empty.
     * </pre>
     */
    boolean hasConstantQueryLength();
    /**
     * <code>optional uint32 constant_query_length = 10;</code>
     *
     * <pre>
     *If query length is constant across all the queries, this field contains the constant length.
     *In such cases, query_length will be empty.
     * </pre>
     */
    int getConstantQueryLength();

    /**
     * <code>repeated uint32 target_length = 8;</code>
     *
     * <pre>
     *Length of the target sequences. One number per target, in the order of increasing target index.
     *The target indexes must be 0..(number of targets - 1).
     * </pre>
     */
    java.util.List<java.lang.Integer> getTargetLengthList();
    /**
     * <code>repeated uint32 target_length = 8;</code>
     *
     * <pre>
     *Length of the target sequences. One number per target, in the order of increasing target index.
     *The target indexes must be 0..(number of targets - 1).
     * </pre>
     */
    int getTargetLengthCount();
    /**
     * <code>repeated uint32 target_length = 8;</code>
     *
     * <pre>
     *Length of the target sequences. One number per target, in the order of increasing target index.
     *The target indexes must be 0..(number of targets - 1).
     * </pre>
     */
    int getTargetLength(int index);

    /**
     * <code>optional bool sorted = 13;</code>
     *
     * <pre>
     *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
     *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
     *have the same target, when a.position &lt; b.position.
     * </pre>
     */
    boolean hasSorted();
    /**
     * <code>optional bool sorted = 13;</code>
     *
     * <pre>
     *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
     *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
     *have the same target, when a.position &lt; b.position.
     * </pre>
     */
    boolean getSorted();

    /**
     * <code>optional bool indexed = 14;</code>
     *
     * <pre>
     *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
     *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
     * </pre>
     */
    boolean hasIndexed();
    /**
     * <code>optional bool indexed = 14;</code>
     *
     * <pre>
     *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
     *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
     * </pre>
     */
    boolean getIndexed();

    /**
     * <code>optional bool query_lengths_stored_in_entries = 15;</code>
     *
     * <pre>
     *True when query lengths are stored in alignment entries (Goby 1.7+).
     * </pre>
     */
    boolean hasQueryLengthsStoredInEntries();
    /**
     * <code>optional bool query_lengths_stored_in_entries = 15;</code>
     *
     * <pre>
     *True when query lengths are stored in alignment entries (Goby 1.7+).
     * </pre>
     */
    boolean getQueryLengthsStoredInEntries();

    /**
     * <code>optional string aligner_name = 17;</code>
     *
     * <pre>
     *Name of the aligner that produced this alignment.
     * </pre>
     */
    boolean hasAlignerName();
    /**
     * <code>optional string aligner_name = 17;</code>
     *
     * <pre>
     *Name of the aligner that produced this alignment.
     * </pre>
     */
    java.lang.String getAlignerName();
    /**
     * <code>optional string aligner_name = 17;</code>
     *
     * <pre>
     *Name of the aligner that produced this alignment.
     * </pre>
     */
    com.google.protobuf.ByteString
        getAlignerNameBytes();

    /**
     * <code>optional string aligner_version = 18;</code>
     *
     * <pre>
     *Version number for the aligner implementation that produced this alignment.
     * </pre>
     */
    boolean hasAlignerVersion();
    /**
     * <code>optional string aligner_version = 18;</code>
     *
     * <pre>
     *Version number for the aligner implementation that produced this alignment.
     * </pre>
     */
    java.lang.String getAlignerVersion();
    /**
     * <code>optional string aligner_version = 18;</code>
     *
     * <pre>
     *Version number for the aligner implementation that produced this alignment.
     * </pre>
     */
    com.google.protobuf.ByteString
        getAlignerVersionBytes();

    /**
     * <code>optional string version = 25;</code>
     *
     * <pre>
     *The version of Goby that created this alignment file.
     * </pre>
     */
    boolean hasVersion();
    /**
     * <code>optional string version = 25;</code>
     *
     * <pre>
     *The version of Goby that created this alignment file.
     * </pre>
     */
    java.lang.String getVersion();
    /**
     * <code>optional string version = 25;</code>
     *
     * <pre>
     *The version of Goby that created this alignment file.
     * </pre>
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    com.google.protobuf.ProtocolStringList
        getSampleBasenameList();
    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    int getSampleBasenameCount();
    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    java.lang.String getSampleBasename(int index);
    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    com.google.protobuf.ByteString
        getSampleBasenameBytes(int index);

    /**
     * <code>optional bool query_indices_were_permuted = 26;</code>
     *
     * <pre>
     *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
     *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
     *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
     *instance), you will need the information in the permutation file (extension basename.perm) and transform back
     *each small index of interest to the original query index.
     * </pre>
     */
    boolean hasQueryIndicesWerePermuted();
    /**
     * <code>optional bool query_indices_were_permuted = 26;</code>
     *
     * <pre>
     *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
     *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
     *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
     *instance), you will need the information in the permutation file (extension basename.perm) and transform back
     *each small index of interest to the original query index.
     * </pre>
     */
    boolean getQueryIndicesWerePermuted();

    /**
     * <code>optional bool query_index_occurrences = 35;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
     *(Since Goby 2.0).
     * </pre>
     */
    boolean hasQueryIndexOccurrences();
    /**
     * <code>optional bool query_index_occurrences = 35;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
     *(Since Goby 2.0).
     * </pre>
     */
    boolean getQueryIndexOccurrences();

    /**
     * <code>optional bool ambiguity_stored_in_entries = 36;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the ambiguity field populated
     *(Since Goby 2.0).
     * </pre>
     */
    boolean hasAmbiguityStoredInEntries();
    /**
     * <code>optional bool ambiguity_stored_in_entries = 36;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the ambiguity field populated
     *(Since Goby 2.0).
     * </pre>
     */
    boolean getAmbiguityStoredInEntries();

    /**
     * <code>optional bool all_read_quality_scores = 40;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
     *(Since Goby 2.0).
     * </pre>
     */
    boolean hasAllReadQualityScores();
    /**
     * <code>optional bool all_read_quality_scores = 40;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
     *(Since Goby 2.0).
     * </pre>
     */
    boolean getAllReadQualityScores();

    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo> 
        getReadOriginList();
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo getReadOrigin(int index);
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    int getReadOriginCount();
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder> 
        getReadOriginOrBuilderList();
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder getReadOriginOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code goby.AlignmentHeader}
   */
  public static final class AlignmentHeader extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.AlignmentHeader)
      AlignmentHeaderOrBuilder {
    // Use AlignmentHeader.newBuilder() to construct.
    private AlignmentHeader(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private AlignmentHeader(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final AlignmentHeader defaultInstance;
    public static AlignmentHeader getDefaultInstance() {
      return defaultInstance;
    }

    public AlignmentHeader getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private AlignmentHeader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = queryNameMapping_.toBuilder();
              }
              queryNameMapping_ = input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(queryNameMapping_);
                queryNameMapping_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 18: {
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = targetNameMapping_.toBuilder();
              }
              targetNameMapping_ = input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(targetNameMapping_);
                targetNameMapping_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 24: {
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                queryLength_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000080;
              }
              queryLength_.add(input.readUInt32());
              break;
            }
            case 26: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080) && input.getBytesUntilLimit() > 0) {
                queryLength_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000080;
              }
              while (input.getBytesUntilLimit() > 0) {
                queryLength_.add(input.readUInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 40: {
              bitField0_ |= 0x00000010;
              numberOfQueries_ = input.readUInt32();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000020;
              numberOfTargets_ = input.readUInt32();
              break;
            }
            case 56: {
              bitField0_ |= 0x00000040;
              numberOfAlignedReads_ = input.readUInt32();
              break;
            }
            case 64: {
              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
                targetLength_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000200;
              }
              targetLength_.add(input.readUInt32());
              break;
            }
            case 66: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200) && input.getBytesUntilLimit() > 0) {
                targetLength_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000200;
              }
              while (input.getBytesUntilLimit() > 0) {
                targetLength_.add(input.readUInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 72: {
              bitField0_ |= 0x00000001;
              smallestSplitQueryIndex_ = input.readUInt32();
              break;
            }
            case 80: {
              bitField0_ |= 0x00000080;
              constantQueryLength_ = input.readUInt32();
              break;
            }
            case 88: {
              bitField0_ |= 0x00000002;
              largestSplitQueryIndex_ = input.readUInt32();
              break;
            }
            case 104: {
              bitField0_ |= 0x00000100;
              sorted_ = input.readBool();
              break;
            }
            case 112: {
              bitField0_ |= 0x00000200;
              indexed_ = input.readBool();
              break;
            }
            case 120: {
              bitField0_ |= 0x00000400;
              queryLengthsStoredInEntries_ = input.readBool();
              break;
            }
            case 138: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000800;
              alignerName_ = bs;
              break;
            }
            case 146: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00001000;
              alignerVersion_ = bs;
              break;
            }
            case 202: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00002000;
              version_ = bs;
              break;
            }
            case 208: {
              bitField0_ |= 0x00004000;
              queryIndicesWerePermuted_ = input.readBool();
              break;
            }
            case 218: {
              if (!((mutable_bitField0_ & 0x00200000) == 0x00200000)) {
                readOrigin_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo>();
                mutable_bitField0_ |= 0x00200000;
              }
              readOrigin_.add(input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.PARSER, extensionRegistry));
              break;
            }
            case 242: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00010000) == 0x00010000)) {
                sampleBasename_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00010000;
              }
              sampleBasename_.add(bs);
              break;
            }
            case 280: {
              bitField0_ |= 0x00008000;
              queryIndexOccurrences_ = input.readBool();
              break;
            }
            case 288: {
              bitField0_ |= 0x00010000;
              ambiguityStoredInEntries_ = input.readBool();
              break;
            }
            case 320: {
              bitField0_ |= 0x00020000;
              allReadQualityScores_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
          queryLength_ = java.util.Collections.unmodifiableList(queryLength_);
        }
        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {
          targetLength_ = java.util.Collections.unmodifiableList(targetLength_);
        }
        if (((mutable_bitField0_ & 0x00200000) == 0x00200000)) {
          readOrigin_ = java.util.Collections.unmodifiableList(readOrigin_);
        }
        if (((mutable_bitField0_ & 0x00010000) == 0x00010000)) {
          sampleBasename_ = sampleBasename_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentHeader_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentHeader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader.Builder.class);
    }

    public static com.google.protobuf.Parser<AlignmentHeader> PARSER =
        new com.google.protobuf.AbstractParser<AlignmentHeader>() {
      public AlignmentHeader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AlignmentHeader(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<AlignmentHeader> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int SMALLEST_SPLIT_QUERY_INDEX_FIELD_NUMBER = 9;
    private int smallestSplitQueryIndex_;
    /**
     * <code>optional uint32 smallest_split_query_index = 9;</code>
     *
     * <pre>
     *The smallest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    public boolean hasSmallestSplitQueryIndex() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional uint32 smallest_split_query_index = 9;</code>
     *
     * <pre>
     *The smallest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    public int getSmallestSplitQueryIndex() {
      return smallestSplitQueryIndex_;
    }

    public static final int LARGEST_SPLIT_QUERY_INDEX_FIELD_NUMBER = 11;
    private int largestSplitQueryIndex_;
    /**
     * <code>optional uint32 largest_split_query_index = 11;</code>
     *
     * <pre>
     *The largest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    public boolean hasLargestSplitQueryIndex() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional uint32 largest_split_query_index = 11;</code>
     *
     * <pre>
     *The largest possible query index in this alignment. Data stored as an array where
     *queryIndex is the array index will be stored with only the elements in the inclusive
     *range [smallestSplitQueryIndex largestSplitQueryIndex]
     *Such data structures include queryLength and some arrays in the TooManyHits data
     *structure.
     * </pre>
     */
    public int getLargestSplitQueryIndex() {
      return largestSplitQueryIndex_;
    }

    public static final int QUERY_NAME_MAPPING_FIELD_NUMBER = 1;
    private edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping queryNameMapping_;
    /**
     * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
     *
     * <pre>
     * Mapping from query identifier name to query index (as used in alignment entries).
     * </pre>
     */
    public boolean hasQueryNameMapping() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
     *
     * <pre>
     * Mapping from query identifier name to query index (as used in alignment entries).
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping getQueryNameMapping() {
      return queryNameMapping_;
    }
    /**
     * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
     *
     * <pre>
     * Mapping from query identifier name to query index (as used in alignment entries).
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder getQueryNameMappingOrBuilder() {
      return queryNameMapping_;
    }

    public static final int TARGET_NAME_MAPPING_FIELD_NUMBER = 2;
    private edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping targetNameMapping_;
    /**
     * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
     *
     * <pre>
     * Mapping from target identifier name to target index (as used in alignment entries).
     * </pre>
     */
    public boolean hasTargetNameMapping() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
     *
     * <pre>
     * Mapping from target identifier name to target index (as used in alignment entries).
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping getTargetNameMapping() {
      return targetNameMapping_;
    }
    /**
     * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
     *
     * <pre>
     * Mapping from target identifier name to target index (as used in alignment entries).
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder getTargetNameMappingOrBuilder() {
      return targetNameMapping_;
    }

    public static final int NUMBER_OF_QUERIES_FIELD_NUMBER = 5;
    private int numberOfQueries_;
    /**
     * <code>optional uint32 number_of_queries = 5;</code>
     *
     * <pre>
     *The number of query sequences
     * </pre>
     */
    public boolean hasNumberOfQueries() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional uint32 number_of_queries = 5;</code>
     *
     * <pre>
     *The number of query sequences
     * </pre>
     */
    public int getNumberOfQueries() {
      return numberOfQueries_;
    }

    public static final int NUMBER_OF_TARGETS_FIELD_NUMBER = 6;
    private int numberOfTargets_;
    /**
     * <code>optional uint32 number_of_targets = 6;</code>
     *
     * <pre>
     *The number of target sequences
     * </pre>
     */
    public boolean hasNumberOfTargets() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional uint32 number_of_targets = 6;</code>
     *
     * <pre>
     *The number of target sequences
     * </pre>
     */
    public int getNumberOfTargets() {
      return numberOfTargets_;
    }

    public static final int NUMBER_OF_ALIGNED_READS_FIELD_NUMBER = 7;
    private int numberOfAlignedReads_;
    /**
     * <code>optional uint32 number_of_aligned_reads = 7;</code>
     *
     * <pre>
     *The number of reads that were aligned to the reference and are represented in this alignment archive.
     * </pre>
     */
    public boolean hasNumberOfAlignedReads() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional uint32 number_of_aligned_reads = 7;</code>
     *
     * <pre>
     *The number of reads that were aligned to the reference and are represented in this alignment archive.
     * </pre>
     */
    public int getNumberOfAlignedReads() {
      return numberOfAlignedReads_;
    }

    public static final int QUERY_LENGTH_FIELD_NUMBER = 3;
    private java.util.List<java.lang.Integer> queryLength_;
    /**
     * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
     *
     * <pre>
     *Length of the query sequences. One number per query, in the order of increasing query index.
     *This information has been moved to the individual alignment entries.
     * </pre>
     */
    @java.lang.Deprecated public java.util.List<java.lang.Integer>
        getQueryLengthList() {
      return queryLength_;
    }
    /**
     * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
     *
     * <pre>
     *Length of the query sequences. One number per query, in the order of increasing query index.
     *This information has been moved to the individual alignment entries.
     * </pre>
     */
    @java.lang.Deprecated public int getQueryLengthCount() {
      return queryLength_.size();
    }
    /**
     * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
     *
     * <pre>
     *Length of the query sequences. One number per query, in the order of increasing query index.
     *This information has been moved to the individual alignment entries.
     * </pre>
     */
    @java.lang.Deprecated public int getQueryLength(int index) {
      return queryLength_.get(index);
    }

    public static final int CONSTANT_QUERY_LENGTH_FIELD_NUMBER = 10;
    private int constantQueryLength_;
    /**
     * <code>optional uint32 constant_query_length = 10;</code>
     *
     * <pre>
     *If query length is constant across all the queries, this field contains the constant length.
     *In such cases, query_length will be empty.
     * </pre>
     */
    public boolean hasConstantQueryLength() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional uint32 constant_query_length = 10;</code>
     *
     * <pre>
     *If query length is constant across all the queries, this field contains the constant length.
     *In such cases, query_length will be empty.
     * </pre>
     */
    public int getConstantQueryLength() {
      return constantQueryLength_;
    }

    public static final int TARGET_LENGTH_FIELD_NUMBER = 8;
    private java.util.List<java.lang.Integer> targetLength_;
    /**
     * <code>repeated uint32 target_length = 8;</code>
     *
     * <pre>
     *Length of the target sequences. One number per target, in the order of increasing target index.
     *The target indexes must be 0..(number of targets - 1).
     * </pre>
     */
    public java.util.List<java.lang.Integer>
        getTargetLengthList() {
      return targetLength_;
    }
    /**
     * <code>repeated uint32 target_length = 8;</code>
     *
     * <pre>
     *Length of the target sequences. One number per target, in the order of increasing target index.
     *The target indexes must be 0..(number of targets - 1).
     * </pre>
     */
    public int getTargetLengthCount() {
      return targetLength_.size();
    }
    /**
     * <code>repeated uint32 target_length = 8;</code>
     *
     * <pre>
     *Length of the target sequences. One number per target, in the order of increasing target index.
     *The target indexes must be 0..(number of targets - 1).
     * </pre>
     */
    public int getTargetLength(int index) {
      return targetLength_.get(index);
    }

    public static final int SORTED_FIELD_NUMBER = 13;
    private boolean sorted_;
    /**
     * <code>optional bool sorted = 13;</code>
     *
     * <pre>
     *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
     *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
     *have the same target, when a.position &lt; b.position.
     * </pre>
     */
    public boolean hasSorted() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional bool sorted = 13;</code>
     *
     * <pre>
     *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
     *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
     *have the same target, when a.position &lt; b.position.
     * </pre>
     */
    public boolean getSorted() {
      return sorted_;
    }

    public static final int INDEXED_FIELD_NUMBER = 14;
    private boolean indexed_;
    /**
     * <code>optional bool indexed = 14;</code>
     *
     * <pre>
     *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
     *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
     * </pre>
     */
    public boolean hasIndexed() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional bool indexed = 14;</code>
     *
     * <pre>
     *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
     *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
     * </pre>
     */
    public boolean getIndexed() {
      return indexed_;
    }

    public static final int QUERY_LENGTHS_STORED_IN_ENTRIES_FIELD_NUMBER = 15;
    private boolean queryLengthsStoredInEntries_;
    /**
     * <code>optional bool query_lengths_stored_in_entries = 15;</code>
     *
     * <pre>
     *True when query lengths are stored in alignment entries (Goby 1.7+).
     * </pre>
     */
    public boolean hasQueryLengthsStoredInEntries() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional bool query_lengths_stored_in_entries = 15;</code>
     *
     * <pre>
     *True when query lengths are stored in alignment entries (Goby 1.7+).
     * </pre>
     */
    public boolean getQueryLengthsStoredInEntries() {
      return queryLengthsStoredInEntries_;
    }

    public static final int ALIGNER_NAME_FIELD_NUMBER = 17;
    private java.lang.Object alignerName_;
    /**
     * <code>optional string aligner_name = 17;</code>
     *
     * <pre>
     *Name of the aligner that produced this alignment.
     * </pre>
     */
    public boolean hasAlignerName() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional string aligner_name = 17;</code>
     *
     * <pre>
     *Name of the aligner that produced this alignment.
     * </pre>
     */
    public java.lang.String getAlignerName() {
      java.lang.Object ref = alignerName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          alignerName_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string aligner_name = 17;</code>
     *
     * <pre>
     *Name of the aligner that produced this alignment.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getAlignerNameBytes() {
      java.lang.Object ref = alignerName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        alignerName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ALIGNER_VERSION_FIELD_NUMBER = 18;
    private java.lang.Object alignerVersion_;
    /**
     * <code>optional string aligner_version = 18;</code>
     *
     * <pre>
     *Version number for the aligner implementation that produced this alignment.
     * </pre>
     */
    public boolean hasAlignerVersion() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <code>optional string aligner_version = 18;</code>
     *
     * <pre>
     *Version number for the aligner implementation that produced this alignment.
     * </pre>
     */
    public java.lang.String getAlignerVersion() {
      java.lang.Object ref = alignerVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          alignerVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string aligner_version = 18;</code>
     *
     * <pre>
     *Version number for the aligner implementation that produced this alignment.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getAlignerVersionBytes() {
      java.lang.Object ref = alignerVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        alignerVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 25;
    private java.lang.Object version_;
    /**
     * <code>optional string version = 25;</code>
     *
     * <pre>
     *The version of Goby that created this alignment file.
     * </pre>
     */
    public boolean hasVersion() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <code>optional string version = 25;</code>
     *
     * <pre>
     *The version of Goby that created this alignment file.
     * </pre>
     */
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string version = 25;</code>
     *
     * <pre>
     *The version of Goby that created this alignment file.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SAMPLE_BASENAME_FIELD_NUMBER = 30;
    private com.google.protobuf.LazyStringList sampleBasename_;
    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getSampleBasenameList() {
      return sampleBasename_;
    }
    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    public int getSampleBasenameCount() {
      return sampleBasename_.size();
    }
    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    public java.lang.String getSampleBasename(int index) {
      return sampleBasename_.get(index);
    }
    /**
     * <code>repeated string sample_basename = 30;</code>
     */
    public com.google.protobuf.ByteString
        getSampleBasenameBytes(int index) {
      return sampleBasename_.getByteString(index);
    }

    public static final int QUERY_INDICES_WERE_PERMUTED_FIELD_NUMBER = 26;
    private boolean queryIndicesWerePermuted_;
    /**
     * <code>optional bool query_indices_were_permuted = 26;</code>
     *
     * <pre>
     *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
     *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
     *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
     *instance), you will need the information in the permutation file (extension basename.perm) and transform back
     *each small index of interest to the original query index.
     * </pre>
     */
    public boolean hasQueryIndicesWerePermuted() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <code>optional bool query_indices_were_permuted = 26;</code>
     *
     * <pre>
     *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
     *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
     *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
     *instance), you will need the information in the permutation file (extension basename.perm) and transform back
     *each small index of interest to the original query index.
     * </pre>
     */
    public boolean getQueryIndicesWerePermuted() {
      return queryIndicesWerePermuted_;
    }

    public static final int QUERY_INDEX_OCCURRENCES_FIELD_NUMBER = 35;
    private boolean queryIndexOccurrences_;
    /**
     * <code>optional bool query_index_occurrences = 35;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
     *(Since Goby 2.0).
     * </pre>
     */
    public boolean hasQueryIndexOccurrences() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <code>optional bool query_index_occurrences = 35;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
     *(Since Goby 2.0).
     * </pre>
     */
    public boolean getQueryIndexOccurrences() {
      return queryIndexOccurrences_;
    }

    public static final int AMBIGUITY_STORED_IN_ENTRIES_FIELD_NUMBER = 36;
    private boolean ambiguityStoredInEntries_;
    /**
     * <code>optional bool ambiguity_stored_in_entries = 36;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the ambiguity field populated
     *(Since Goby 2.0).
     * </pre>
     */
    public boolean hasAmbiguityStoredInEntries() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <code>optional bool ambiguity_stored_in_entries = 36;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the ambiguity field populated
     *(Since Goby 2.0).
     * </pre>
     */
    public boolean getAmbiguityStoredInEntries() {
      return ambiguityStoredInEntries_;
    }

    public static final int ALL_READ_QUALITY_SCORES_FIELD_NUMBER = 40;
    private boolean allReadQualityScores_;
    /**
     * <code>optional bool all_read_quality_scores = 40;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
     *(Since Goby 2.0).
     * </pre>
     */
    public boolean hasAllReadQualityScores() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <code>optional bool all_read_quality_scores = 40;</code>
     *
     * <pre>
     *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
     *(Since Goby 2.0).
     * </pre>
     */
    public boolean getAllReadQualityScores() {
      return allReadQualityScores_;
    }

    public static final int READ_ORIGIN_FIELD_NUMBER = 27;
    private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo> readOrigin_;
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo> getReadOriginList() {
      return readOrigin_;
    }
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder> 
        getReadOriginOrBuilderList() {
      return readOrigin_;
    }
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    public int getReadOriginCount() {
      return readOrigin_.size();
    }
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo getReadOrigin(int index) {
      return readOrigin_.get(index);
    }
    /**
     * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
     *
     * <pre>
     *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
     *efficient. Instead of storing strings, we use integers in the entries.
     *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
     *(Since Goby 2.0).
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder getReadOriginOrBuilder(
        int index) {
      return readOrigin_.get(index);
    }

    private void initFields() {
      smallestSplitQueryIndex_ = 0;
      largestSplitQueryIndex_ = 0;
      queryNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
      targetNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
      numberOfQueries_ = 0;
      numberOfTargets_ = 0;
      numberOfAlignedReads_ = 0;
      queryLength_ = java.util.Collections.emptyList();
      constantQueryLength_ = 0;
      targetLength_ = java.util.Collections.emptyList();
      sorted_ = false;
      indexed_ = false;
      queryLengthsStoredInEntries_ = false;
      alignerName_ = "";
      alignerVersion_ = "";
      version_ = "";
      sampleBasename_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      queryIndicesWerePermuted_ = false;
      queryIndexOccurrences_ = false;
      ambiguityStoredInEntries_ = false;
      allReadQualityScores_ = false;
      readOrigin_ = java.util.Collections.emptyList();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasQueryNameMapping()) {
        if (!getQueryNameMapping().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasTargetNameMapping()) {
        if (!getTargetNameMapping().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getReadOriginCount(); i++) {
        if (!getReadOrigin(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(1, queryNameMapping_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(2, targetNameMapping_);
      }
      for (int i = 0; i < queryLength_.size(); i++) {
        output.writeUInt32(3, queryLength_.get(i));
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeUInt32(5, numberOfQueries_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeUInt32(6, numberOfTargets_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeUInt32(7, numberOfAlignedReads_);
      }
      for (int i = 0; i < targetLength_.size(); i++) {
        output.writeUInt32(8, targetLength_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(9, smallestSplitQueryIndex_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeUInt32(10, constantQueryLength_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(11, largestSplitQueryIndex_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeBool(13, sorted_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeBool(14, indexed_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeBool(15, queryLengthsStoredInEntries_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeBytes(17, getAlignerNameBytes());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeBytes(18, getAlignerVersionBytes());
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeBytes(25, getVersionBytes());
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeBool(26, queryIndicesWerePermuted_);
      }
      for (int i = 0; i < readOrigin_.size(); i++) {
        output.writeMessage(27, readOrigin_.get(i));
      }
      for (int i = 0; i < sampleBasename_.size(); i++) {
        output.writeBytes(30, sampleBasename_.getByteString(i));
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeBool(35, queryIndexOccurrences_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeBool(36, ambiguityStoredInEntries_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeBool(40, allReadQualityScores_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, queryNameMapping_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, targetNameMapping_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < queryLength_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(queryLength_.get(i));
        }
        size += dataSize;
        size += 1 * getQueryLengthList().size();
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, numberOfQueries_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, numberOfTargets_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, numberOfAlignedReads_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < targetLength_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(targetLength_.get(i));
        }
        size += dataSize;
        size += 1 * getTargetLengthList().size();
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(9, smallestSplitQueryIndex_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, constantQueryLength_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, largestSplitQueryIndex_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(13, sorted_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(14, indexed_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, queryLengthsStoredInEntries_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(17, getAlignerNameBytes());
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(18, getAlignerVersionBytes());
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(25, getVersionBytes());
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(26, queryIndicesWerePermuted_);
      }
      for (int i = 0; i < readOrigin_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(27, readOrigin_.get(i));
      }
      {
        int dataSize = 0;
        for (int i = 0; i < sampleBasename_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(sampleBasename_.getByteString(i));
        }
        size += dataSize;
        size += 2 * getSampleBasenameList().size();
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(35, queryIndexOccurrences_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(36, ambiguityStoredInEntries_);
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(40, allReadQualityScores_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.AlignmentHeader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.AlignmentHeader)
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentHeader_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentHeader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getQueryNameMappingFieldBuilder();
          getTargetNameMappingFieldBuilder();
          getReadOriginFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        smallestSplitQueryIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        largestSplitQueryIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        if (queryNameMappingBuilder_ == null) {
          queryNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
        } else {
          queryNameMappingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (targetNameMappingBuilder_ == null) {
          targetNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
        } else {
          targetNameMappingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        numberOfQueries_ = 0;
        bitField0_ = (bitField0_ & ~0x00000010);
        numberOfTargets_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        numberOfAlignedReads_ = 0;
        bitField0_ = (bitField0_ & ~0x00000040);
        queryLength_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        constantQueryLength_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        targetLength_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
        sorted_ = false;
        bitField0_ = (bitField0_ & ~0x00000400);
        indexed_ = false;
        bitField0_ = (bitField0_ & ~0x00000800);
        queryLengthsStoredInEntries_ = false;
        bitField0_ = (bitField0_ & ~0x00001000);
        alignerName_ = "";
        bitField0_ = (bitField0_ & ~0x00002000);
        alignerVersion_ = "";
        bitField0_ = (bitField0_ & ~0x00004000);
        version_ = "";
        bitField0_ = (bitField0_ & ~0x00008000);
        sampleBasename_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00010000);
        queryIndicesWerePermuted_ = false;
        bitField0_ = (bitField0_ & ~0x00020000);
        queryIndexOccurrences_ = false;
        bitField0_ = (bitField0_ & ~0x00040000);
        ambiguityStoredInEntries_ = false;
        bitField0_ = (bitField0_ & ~0x00080000);
        allReadQualityScores_ = false;
        bitField0_ = (bitField0_ & ~0x00100000);
        if (readOriginBuilder_ == null) {
          readOrigin_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00200000);
        } else {
          readOriginBuilder_.clear();
        }
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentHeader_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader build() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader result = new edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.smallestSplitQueryIndex_ = smallestSplitQueryIndex_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.largestSplitQueryIndex_ = largestSplitQueryIndex_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (queryNameMappingBuilder_ == null) {
          result.queryNameMapping_ = queryNameMapping_;
        } else {
          result.queryNameMapping_ = queryNameMappingBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (targetNameMappingBuilder_ == null) {
          result.targetNameMapping_ = targetNameMapping_;
        } else {
          result.targetNameMapping_ = targetNameMappingBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.numberOfQueries_ = numberOfQueries_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.numberOfTargets_ = numberOfTargets_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.numberOfAlignedReads_ = numberOfAlignedReads_;
        if (((bitField0_ & 0x00000080) == 0x00000080)) {
          queryLength_ = java.util.Collections.unmodifiableList(queryLength_);
          bitField0_ = (bitField0_ & ~0x00000080);
        }
        result.queryLength_ = queryLength_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000080;
        }
        result.constantQueryLength_ = constantQueryLength_;
        if (((bitField0_ & 0x00000200) == 0x00000200)) {
          targetLength_ = java.util.Collections.unmodifiableList(targetLength_);
          bitField0_ = (bitField0_ & ~0x00000200);
        }
        result.targetLength_ = targetLength_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000100;
        }
        result.sorted_ = sorted_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000200;
        }
        result.indexed_ = indexed_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00000400;
        }
        result.queryLengthsStoredInEntries_ = queryLengthsStoredInEntries_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00000800;
        }
        result.alignerName_ = alignerName_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.alignerVersion_ = alignerVersion_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.version_ = version_;
        if (((bitField0_ & 0x00010000) == 0x00010000)) {
          sampleBasename_ = sampleBasename_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00010000);
        }
        result.sampleBasename_ = sampleBasename_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.queryIndicesWerePermuted_ = queryIndicesWerePermuted_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.queryIndexOccurrences_ = queryIndexOccurrences_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.ambiguityStoredInEntries_ = ambiguityStoredInEntries_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.allReadQualityScores_ = allReadQualityScores_;
        if (readOriginBuilder_ == null) {
          if (((bitField0_ & 0x00200000) == 0x00200000)) {
            readOrigin_ = java.util.Collections.unmodifiableList(readOrigin_);
            bitField0_ = (bitField0_ & ~0x00200000);
          }
          result.readOrigin_ = readOrigin_;
        } else {
          result.readOrigin_ = readOriginBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader.getDefaultInstance()) return this;
        if (other.hasSmallestSplitQueryIndex()) {
          setSmallestSplitQueryIndex(other.getSmallestSplitQueryIndex());
        }
        if (other.hasLargestSplitQueryIndex()) {
          setLargestSplitQueryIndex(other.getLargestSplitQueryIndex());
        }
        if (other.hasQueryNameMapping()) {
          mergeQueryNameMapping(other.getQueryNameMapping());
        }
        if (other.hasTargetNameMapping()) {
          mergeTargetNameMapping(other.getTargetNameMapping());
        }
        if (other.hasNumberOfQueries()) {
          setNumberOfQueries(other.getNumberOfQueries());
        }
        if (other.hasNumberOfTargets()) {
          setNumberOfTargets(other.getNumberOfTargets());
        }
        if (other.hasNumberOfAlignedReads()) {
          setNumberOfAlignedReads(other.getNumberOfAlignedReads());
        }
        if (!other.queryLength_.isEmpty()) {
          if (queryLength_.isEmpty()) {
            queryLength_ = other.queryLength_;
            bitField0_ = (bitField0_ & ~0x00000080);
          } else {
            ensureQueryLengthIsMutable();
            queryLength_.addAll(other.queryLength_);
          }
          onChanged();
        }
        if (other.hasConstantQueryLength()) {
          setConstantQueryLength(other.getConstantQueryLength());
        }
        if (!other.targetLength_.isEmpty()) {
          if (targetLength_.isEmpty()) {
            targetLength_ = other.targetLength_;
            bitField0_ = (bitField0_ & ~0x00000200);
          } else {
            ensureTargetLengthIsMutable();
            targetLength_.addAll(other.targetLength_);
          }
          onChanged();
        }
        if (other.hasSorted()) {
          setSorted(other.getSorted());
        }
        if (other.hasIndexed()) {
          setIndexed(other.getIndexed());
        }
        if (other.hasQueryLengthsStoredInEntries()) {
          setQueryLengthsStoredInEntries(other.getQueryLengthsStoredInEntries());
        }
        if (other.hasAlignerName()) {
          bitField0_ |= 0x00002000;
          alignerName_ = other.alignerName_;
          onChanged();
        }
        if (other.hasAlignerVersion()) {
          bitField0_ |= 0x00004000;
          alignerVersion_ = other.alignerVersion_;
          onChanged();
        }
        if (other.hasVersion()) {
          bitField0_ |= 0x00008000;
          version_ = other.version_;
          onChanged();
        }
        if (!other.sampleBasename_.isEmpty()) {
          if (sampleBasename_.isEmpty()) {
            sampleBasename_ = other.sampleBasename_;
            bitField0_ = (bitField0_ & ~0x00010000);
          } else {
            ensureSampleBasenameIsMutable();
            sampleBasename_.addAll(other.sampleBasename_);
          }
          onChanged();
        }
        if (other.hasQueryIndicesWerePermuted()) {
          setQueryIndicesWerePermuted(other.getQueryIndicesWerePermuted());
        }
        if (other.hasQueryIndexOccurrences()) {
          setQueryIndexOccurrences(other.getQueryIndexOccurrences());
        }
        if (other.hasAmbiguityStoredInEntries()) {
          setAmbiguityStoredInEntries(other.getAmbiguityStoredInEntries());
        }
        if (other.hasAllReadQualityScores()) {
          setAllReadQualityScores(other.getAllReadQualityScores());
        }
        if (readOriginBuilder_ == null) {
          if (!other.readOrigin_.isEmpty()) {
            if (readOrigin_.isEmpty()) {
              readOrigin_ = other.readOrigin_;
              bitField0_ = (bitField0_ & ~0x00200000);
            } else {
              ensureReadOriginIsMutable();
              readOrigin_.addAll(other.readOrigin_);
            }
            onChanged();
          }
        } else {
          if (!other.readOrigin_.isEmpty()) {
            if (readOriginBuilder_.isEmpty()) {
              readOriginBuilder_.dispose();
              readOriginBuilder_ = null;
              readOrigin_ = other.readOrigin_;
              bitField0_ = (bitField0_ & ~0x00200000);
              readOriginBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getReadOriginFieldBuilder() : null;
            } else {
              readOriginBuilder_.addAllMessages(other.readOrigin_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (hasQueryNameMapping()) {
          if (!getQueryNameMapping().isInitialized()) {
            
            return false;
          }
        }
        if (hasTargetNameMapping()) {
          if (!getTargetNameMapping().isInitialized()) {
            
            return false;
          }
        }
        for (int i = 0; i < getReadOriginCount(); i++) {
          if (!getReadOrigin(i).isInitialized()) {
            
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.AlignmentHeader) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int smallestSplitQueryIndex_ ;
      /**
       * <code>optional uint32 smallest_split_query_index = 9;</code>
       *
       * <pre>
       *The smallest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public boolean hasSmallestSplitQueryIndex() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional uint32 smallest_split_query_index = 9;</code>
       *
       * <pre>
       *The smallest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public int getSmallestSplitQueryIndex() {
        return smallestSplitQueryIndex_;
      }
      /**
       * <code>optional uint32 smallest_split_query_index = 9;</code>
       *
       * <pre>
       *The smallest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public Builder setSmallestSplitQueryIndex(int value) {
        bitField0_ |= 0x00000001;
        smallestSplitQueryIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 smallest_split_query_index = 9;</code>
       *
       * <pre>
       *The smallest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public Builder clearSmallestSplitQueryIndex() {
        bitField0_ = (bitField0_ & ~0x00000001);
        smallestSplitQueryIndex_ = 0;
        onChanged();
        return this;
      }

      private int largestSplitQueryIndex_ ;
      /**
       * <code>optional uint32 largest_split_query_index = 11;</code>
       *
       * <pre>
       *The largest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public boolean hasLargestSplitQueryIndex() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional uint32 largest_split_query_index = 11;</code>
       *
       * <pre>
       *The largest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public int getLargestSplitQueryIndex() {
        return largestSplitQueryIndex_;
      }
      /**
       * <code>optional uint32 largest_split_query_index = 11;</code>
       *
       * <pre>
       *The largest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public Builder setLargestSplitQueryIndex(int value) {
        bitField0_ |= 0x00000002;
        largestSplitQueryIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 largest_split_query_index = 11;</code>
       *
       * <pre>
       *The largest possible query index in this alignment. Data stored as an array where
       *queryIndex is the array index will be stored with only the elements in the inclusive
       *range [smallestSplitQueryIndex largestSplitQueryIndex]
       *Such data structures include queryLength and some arrays in the TooManyHits data
       *structure.
       * </pre>
       */
      public Builder clearLargestSplitQueryIndex() {
        bitField0_ = (bitField0_ & ~0x00000002);
        largestSplitQueryIndex_ = 0;
        onChanged();
        return this;
      }

      private edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping queryNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder> queryNameMappingBuilder_;
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public boolean hasQueryNameMapping() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping getQueryNameMapping() {
        if (queryNameMappingBuilder_ == null) {
          return queryNameMapping_;
        } else {
          return queryNameMappingBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public Builder setQueryNameMapping(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping value) {
        if (queryNameMappingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          queryNameMapping_ = value;
          onChanged();
        } else {
          queryNameMappingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public Builder setQueryNameMapping(
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder builderForValue) {
        if (queryNameMappingBuilder_ == null) {
          queryNameMapping_ = builderForValue.build();
          onChanged();
        } else {
          queryNameMappingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public Builder mergeQueryNameMapping(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping value) {
        if (queryNameMappingBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              queryNameMapping_ != edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance()) {
            queryNameMapping_ =
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.newBuilder(queryNameMapping_).mergeFrom(value).buildPartial();
          } else {
            queryNameMapping_ = value;
          }
          onChanged();
        } else {
          queryNameMappingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public Builder clearQueryNameMapping() {
        if (queryNameMappingBuilder_ == null) {
          queryNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
          onChanged();
        } else {
          queryNameMappingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder getQueryNameMappingBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getQueryNameMappingFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder getQueryNameMappingOrBuilder() {
        if (queryNameMappingBuilder_ != null) {
          return queryNameMappingBuilder_.getMessageOrBuilder();
        } else {
          return queryNameMapping_;
        }
      }
      /**
       * <code>optional .goby.IdentifierMapping query_name_mapping = 1;</code>
       *
       * <pre>
       * Mapping from query identifier name to query index (as used in alignment entries).
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder> 
          getQueryNameMappingFieldBuilder() {
        if (queryNameMappingBuilder_ == null) {
          queryNameMappingBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder>(
                  getQueryNameMapping(),
                  getParentForChildren(),
                  isClean());
          queryNameMapping_ = null;
        }
        return queryNameMappingBuilder_;
      }

      private edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping targetNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder> targetNameMappingBuilder_;
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public boolean hasTargetNameMapping() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping getTargetNameMapping() {
        if (targetNameMappingBuilder_ == null) {
          return targetNameMapping_;
        } else {
          return targetNameMappingBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public Builder setTargetNameMapping(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping value) {
        if (targetNameMappingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          targetNameMapping_ = value;
          onChanged();
        } else {
          targetNameMappingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public Builder setTargetNameMapping(
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder builderForValue) {
        if (targetNameMappingBuilder_ == null) {
          targetNameMapping_ = builderForValue.build();
          onChanged();
        } else {
          targetNameMappingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public Builder mergeTargetNameMapping(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping value) {
        if (targetNameMappingBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008) &&
              targetNameMapping_ != edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance()) {
            targetNameMapping_ =
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.newBuilder(targetNameMapping_).mergeFrom(value).buildPartial();
          } else {
            targetNameMapping_ = value;
          }
          onChanged();
        } else {
          targetNameMappingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public Builder clearTargetNameMapping() {
        if (targetNameMappingBuilder_ == null) {
          targetNameMapping_ = edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
          onChanged();
        } else {
          targetNameMappingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder getTargetNameMappingBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getTargetNameMappingFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder getTargetNameMappingOrBuilder() {
        if (targetNameMappingBuilder_ != null) {
          return targetNameMappingBuilder_.getMessageOrBuilder();
        } else {
          return targetNameMapping_;
        }
      }
      /**
       * <code>optional .goby.IdentifierMapping target_name_mapping = 2;</code>
       *
       * <pre>
       * Mapping from target identifier name to target index (as used in alignment entries).
       * </pre>
       */
      private com.google.protobuf.SingleFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder> 
          getTargetNameMappingFieldBuilder() {
        if (targetNameMappingBuilder_ == null) {
          targetNameMappingBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder>(
                  getTargetNameMapping(),
                  getParentForChildren(),
                  isClean());
          targetNameMapping_ = null;
        }
        return targetNameMappingBuilder_;
      }

      private int numberOfQueries_ ;
      /**
       * <code>optional uint32 number_of_queries = 5;</code>
       *
       * <pre>
       *The number of query sequences
       * </pre>
       */
      public boolean hasNumberOfQueries() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional uint32 number_of_queries = 5;</code>
       *
       * <pre>
       *The number of query sequences
       * </pre>
       */
      public int getNumberOfQueries() {
        return numberOfQueries_;
      }
      /**
       * <code>optional uint32 number_of_queries = 5;</code>
       *
       * <pre>
       *The number of query sequences
       * </pre>
       */
      public Builder setNumberOfQueries(int value) {
        bitField0_ |= 0x00000010;
        numberOfQueries_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 number_of_queries = 5;</code>
       *
       * <pre>
       *The number of query sequences
       * </pre>
       */
      public Builder clearNumberOfQueries() {
        bitField0_ = (bitField0_ & ~0x00000010);
        numberOfQueries_ = 0;
        onChanged();
        return this;
      }

      private int numberOfTargets_ ;
      /**
       * <code>optional uint32 number_of_targets = 6;</code>
       *
       * <pre>
       *The number of target sequences
       * </pre>
       */
      public boolean hasNumberOfTargets() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional uint32 number_of_targets = 6;</code>
       *
       * <pre>
       *The number of target sequences
       * </pre>
       */
      public int getNumberOfTargets() {
        return numberOfTargets_;
      }
      /**
       * <code>optional uint32 number_of_targets = 6;</code>
       *
       * <pre>
       *The number of target sequences
       * </pre>
       */
      public Builder setNumberOfTargets(int value) {
        bitField0_ |= 0x00000020;
        numberOfTargets_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 number_of_targets = 6;</code>
       *
       * <pre>
       *The number of target sequences
       * </pre>
       */
      public Builder clearNumberOfTargets() {
        bitField0_ = (bitField0_ & ~0x00000020);
        numberOfTargets_ = 0;
        onChanged();
        return this;
      }

      private int numberOfAlignedReads_ ;
      /**
       * <code>optional uint32 number_of_aligned_reads = 7;</code>
       *
       * <pre>
       *The number of reads that were aligned to the reference and are represented in this alignment archive.
       * </pre>
       */
      public boolean hasNumberOfAlignedReads() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional uint32 number_of_aligned_reads = 7;</code>
       *
       * <pre>
       *The number of reads that were aligned to the reference and are represented in this alignment archive.
       * </pre>
       */
      public int getNumberOfAlignedReads() {
        return numberOfAlignedReads_;
      }
      /**
       * <code>optional uint32 number_of_aligned_reads = 7;</code>
       *
       * <pre>
       *The number of reads that were aligned to the reference and are represented in this alignment archive.
       * </pre>
       */
      public Builder setNumberOfAlignedReads(int value) {
        bitField0_ |= 0x00000040;
        numberOfAlignedReads_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 number_of_aligned_reads = 7;</code>
       *
       * <pre>
       *The number of reads that were aligned to the reference and are represented in this alignment archive.
       * </pre>
       */
      public Builder clearNumberOfAlignedReads() {
        bitField0_ = (bitField0_ & ~0x00000040);
        numberOfAlignedReads_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> queryLength_ = java.util.Collections.emptyList();
      private void ensureQueryLengthIsMutable() {
        if (!((bitField0_ & 0x00000080) == 0x00000080)) {
          queryLength_ = new java.util.ArrayList<java.lang.Integer>(queryLength_);
          bitField0_ |= 0x00000080;
         }
      }
      /**
       * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
       *
       * <pre>
       *Length of the query sequences. One number per query, in the order of increasing query index.
       *This information has been moved to the individual alignment entries.
       * </pre>
       */
      @java.lang.Deprecated public java.util.List<java.lang.Integer>
          getQueryLengthList() {
        return java.util.Collections.unmodifiableList(queryLength_);
      }
      /**
       * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
       *
       * <pre>
       *Length of the query sequences. One number per query, in the order of increasing query index.
       *This information has been moved to the individual alignment entries.
       * </pre>
       */
      @java.lang.Deprecated public int getQueryLengthCount() {
        return queryLength_.size();
      }
      /**
       * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
       *
       * <pre>
       *Length of the query sequences. One number per query, in the order of increasing query index.
       *This information has been moved to the individual alignment entries.
       * </pre>
       */
      @java.lang.Deprecated public int getQueryLength(int index) {
        return queryLength_.get(index);
      }
      /**
       * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
       *
       * <pre>
       *Length of the query sequences. One number per query, in the order of increasing query index.
       *This information has been moved to the individual alignment entries.
       * </pre>
       */
      @java.lang.Deprecated public Builder setQueryLength(
          int index, int value) {
        ensureQueryLengthIsMutable();
        queryLength_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
       *
       * <pre>
       *Length of the query sequences. One number per query, in the order of increasing query index.
       *This information has been moved to the individual alignment entries.
       * </pre>
       */
      @java.lang.Deprecated public Builder addQueryLength(int value) {
        ensureQueryLengthIsMutable();
        queryLength_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
       *
       * <pre>
       *Length of the query sequences. One number per query, in the order of increasing query index.
       *This information has been moved to the individual alignment entries.
       * </pre>
       */
      @java.lang.Deprecated public Builder addAllQueryLength(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureQueryLengthIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, queryLength_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 query_length = 3 [deprecated = true];</code>
       *
       * <pre>
       *Length of the query sequences. One number per query, in the order of increasing query index.
       *This information has been moved to the individual alignment entries.
       * </pre>
       */
      @java.lang.Deprecated public Builder clearQueryLength() {
        queryLength_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }

      private int constantQueryLength_ ;
      /**
       * <code>optional uint32 constant_query_length = 10;</code>
       *
       * <pre>
       *If query length is constant across all the queries, this field contains the constant length.
       *In such cases, query_length will be empty.
       * </pre>
       */
      public boolean hasConstantQueryLength() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional uint32 constant_query_length = 10;</code>
       *
       * <pre>
       *If query length is constant across all the queries, this field contains the constant length.
       *In such cases, query_length will be empty.
       * </pre>
       */
      public int getConstantQueryLength() {
        return constantQueryLength_;
      }
      /**
       * <code>optional uint32 constant_query_length = 10;</code>
       *
       * <pre>
       *If query length is constant across all the queries, this field contains the constant length.
       *In such cases, query_length will be empty.
       * </pre>
       */
      public Builder setConstantQueryLength(int value) {
        bitField0_ |= 0x00000100;
        constantQueryLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 constant_query_length = 10;</code>
       *
       * <pre>
       *If query length is constant across all the queries, this field contains the constant length.
       *In such cases, query_length will be empty.
       * </pre>
       */
      public Builder clearConstantQueryLength() {
        bitField0_ = (bitField0_ & ~0x00000100);
        constantQueryLength_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> targetLength_ = java.util.Collections.emptyList();
      private void ensureTargetLengthIsMutable() {
        if (!((bitField0_ & 0x00000200) == 0x00000200)) {
          targetLength_ = new java.util.ArrayList<java.lang.Integer>(targetLength_);
          bitField0_ |= 0x00000200;
         }
      }
      /**
       * <code>repeated uint32 target_length = 8;</code>
       *
       * <pre>
       *Length of the target sequences. One number per target, in the order of increasing target index.
       *The target indexes must be 0..(number of targets - 1).
       * </pre>
       */
      public java.util.List<java.lang.Integer>
          getTargetLengthList() {
        return java.util.Collections.unmodifiableList(targetLength_);
      }
      /**
       * <code>repeated uint32 target_length = 8;</code>
       *
       * <pre>
       *Length of the target sequences. One number per target, in the order of increasing target index.
       *The target indexes must be 0..(number of targets - 1).
       * </pre>
       */
      public int getTargetLengthCount() {
        return targetLength_.size();
      }
      /**
       * <code>repeated uint32 target_length = 8;</code>
       *
       * <pre>
       *Length of the target sequences. One number per target, in the order of increasing target index.
       *The target indexes must be 0..(number of targets - 1).
       * </pre>
       */
      public int getTargetLength(int index) {
        return targetLength_.get(index);
      }
      /**
       * <code>repeated uint32 target_length = 8;</code>
       *
       * <pre>
       *Length of the target sequences. One number per target, in the order of increasing target index.
       *The target indexes must be 0..(number of targets - 1).
       * </pre>
       */
      public Builder setTargetLength(
          int index, int value) {
        ensureTargetLengthIsMutable();
        targetLength_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 target_length = 8;</code>
       *
       * <pre>
       *Length of the target sequences. One number per target, in the order of increasing target index.
       *The target indexes must be 0..(number of targets - 1).
       * </pre>
       */
      public Builder addTargetLength(int value) {
        ensureTargetLengthIsMutable();
        targetLength_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 target_length = 8;</code>
       *
       * <pre>
       *Length of the target sequences. One number per target, in the order of increasing target index.
       *The target indexes must be 0..(number of targets - 1).
       * </pre>
       */
      public Builder addAllTargetLength(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureTargetLengthIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, targetLength_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 target_length = 8;</code>
       *
       * <pre>
       *Length of the target sequences. One number per target, in the order of increasing target index.
       *The target indexes must be 0..(number of targets - 1).
       * </pre>
       */
      public Builder clearTargetLength() {
        targetLength_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }

      private boolean sorted_ ;
      /**
       * <code>optional bool sorted = 13;</code>
       *
       * <pre>
       *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
       *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
       *have the same target, when a.position &lt; b.position.
       * </pre>
       */
      public boolean hasSorted() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional bool sorted = 13;</code>
       *
       * <pre>
       *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
       *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
       *have the same target, when a.position &lt; b.position.
       * </pre>
       */
      public boolean getSorted() {
        return sorted_;
      }
      /**
       * <code>optional bool sorted = 13;</code>
       *
       * <pre>
       *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
       *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
       *have the same target, when a.position &lt; b.position.
       * </pre>
       */
      public Builder setSorted(boolean value) {
        bitField0_ |= 0x00000400;
        sorted_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool sorted = 13;</code>
       *
       * <pre>
       *Indicates whether this alignment is sorted by position. True: the alignment entries occur in sorted
       *order, such that entry a occurs before entry b if a.targetIndex&lt; b.targetIndex or, when entries
       *have the same target, when a.position &lt; b.position.
       * </pre>
       */
      public Builder clearSorted() {
        bitField0_ = (bitField0_ & ~0x00000400);
        sorted_ = false;
        onChanged();
        return this;
      }

      private boolean indexed_ ;
      /**
       * <code>optional bool indexed = 14;</code>
       *
       * <pre>
       *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
       *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
       * </pre>
       */
      public boolean hasIndexed() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <code>optional bool indexed = 14;</code>
       *
       * <pre>
       *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
       *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
       * </pre>
       */
      public boolean getIndexed() {
        return indexed_;
      }
      /**
       * <code>optional bool indexed = 14;</code>
       *
       * <pre>
       *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
       *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
       * </pre>
       */
      public Builder setIndexed(boolean value) {
        bitField0_ |= 0x00000800;
        indexed_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool indexed = 14;</code>
       *
       * <pre>
       *Indicates whether this alignment is indexed by position. When this attribute is true, a file called
       *'basename'.index exists that contains the AlignmentIndex message (GZip compressed).
       * </pre>
       */
      public Builder clearIndexed() {
        bitField0_ = (bitField0_ & ~0x00000800);
        indexed_ = false;
        onChanged();
        return this;
      }

      private boolean queryLengthsStoredInEntries_ ;
      /**
       * <code>optional bool query_lengths_stored_in_entries = 15;</code>
       *
       * <pre>
       *True when query lengths are stored in alignment entries (Goby 1.7+).
       * </pre>
       */
      public boolean hasQueryLengthsStoredInEntries() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <code>optional bool query_lengths_stored_in_entries = 15;</code>
       *
       * <pre>
       *True when query lengths are stored in alignment entries (Goby 1.7+).
       * </pre>
       */
      public boolean getQueryLengthsStoredInEntries() {
        return queryLengthsStoredInEntries_;
      }
      /**
       * <code>optional bool query_lengths_stored_in_entries = 15;</code>
       *
       * <pre>
       *True when query lengths are stored in alignment entries (Goby 1.7+).
       * </pre>
       */
      public Builder setQueryLengthsStoredInEntries(boolean value) {
        bitField0_ |= 0x00001000;
        queryLengthsStoredInEntries_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool query_lengths_stored_in_entries = 15;</code>
       *
       * <pre>
       *True when query lengths are stored in alignment entries (Goby 1.7+).
       * </pre>
       */
      public Builder clearQueryLengthsStoredInEntries() {
        bitField0_ = (bitField0_ & ~0x00001000);
        queryLengthsStoredInEntries_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object alignerName_ = "";
      /**
       * <code>optional string aligner_name = 17;</code>
       *
       * <pre>
       *Name of the aligner that produced this alignment.
       * </pre>
       */
      public boolean hasAlignerName() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <code>optional string aligner_name = 17;</code>
       *
       * <pre>
       *Name of the aligner that produced this alignment.
       * </pre>
       */
      public java.lang.String getAlignerName() {
        java.lang.Object ref = alignerName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            alignerName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string aligner_name = 17;</code>
       *
       * <pre>
       *Name of the aligner that produced this alignment.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getAlignerNameBytes() {
        java.lang.Object ref = alignerName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          alignerName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string aligner_name = 17;</code>
       *
       * <pre>
       *Name of the aligner that produced this alignment.
       * </pre>
       */
      public Builder setAlignerName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00002000;
        alignerName_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string aligner_name = 17;</code>
       *
       * <pre>
       *Name of the aligner that produced this alignment.
       * </pre>
       */
      public Builder clearAlignerName() {
        bitField0_ = (bitField0_ & ~0x00002000);
        alignerName_ = getDefaultInstance().getAlignerName();
        onChanged();
        return this;
      }
      /**
       * <code>optional string aligner_name = 17;</code>
       *
       * <pre>
       *Name of the aligner that produced this alignment.
       * </pre>
       */
      public Builder setAlignerNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00002000;
        alignerName_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object alignerVersion_ = "";
      /**
       * <code>optional string aligner_version = 18;</code>
       *
       * <pre>
       *Version number for the aligner implementation that produced this alignment.
       * </pre>
       */
      public boolean hasAlignerVersion() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <code>optional string aligner_version = 18;</code>
       *
       * <pre>
       *Version number for the aligner implementation that produced this alignment.
       * </pre>
       */
      public java.lang.String getAlignerVersion() {
        java.lang.Object ref = alignerVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            alignerVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string aligner_version = 18;</code>
       *
       * <pre>
       *Version number for the aligner implementation that produced this alignment.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getAlignerVersionBytes() {
        java.lang.Object ref = alignerVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          alignerVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string aligner_version = 18;</code>
       *
       * <pre>
       *Version number for the aligner implementation that produced this alignment.
       * </pre>
       */
      public Builder setAlignerVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00004000;
        alignerVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string aligner_version = 18;</code>
       *
       * <pre>
       *Version number for the aligner implementation that produced this alignment.
       * </pre>
       */
      public Builder clearAlignerVersion() {
        bitField0_ = (bitField0_ & ~0x00004000);
        alignerVersion_ = getDefaultInstance().getAlignerVersion();
        onChanged();
        return this;
      }
      /**
       * <code>optional string aligner_version = 18;</code>
       *
       * <pre>
       *Version number for the aligner implementation that produced this alignment.
       * </pre>
       */
      public Builder setAlignerVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00004000;
        alignerVersion_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <code>optional string version = 25;</code>
       *
       * <pre>
       *The version of Goby that created this alignment file.
       * </pre>
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <code>optional string version = 25;</code>
       *
       * <pre>
       *The version of Goby that created this alignment file.
       * </pre>
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string version = 25;</code>
       *
       * <pre>
       *The version of Goby that created this alignment file.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string version = 25;</code>
       *
       * <pre>
       *The version of Goby that created this alignment file.
       * </pre>
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
        version_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 25;</code>
       *
       * <pre>
       *The version of Goby that created this alignment file.
       * </pre>
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00008000);
        version_ = getDefaultInstance().getVersion();
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 25;</code>
       *
       * <pre>
       *The version of Goby that created this alignment file.
       * </pre>
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
        version_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList sampleBasename_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureSampleBasenameIsMutable() {
        if (!((bitField0_ & 0x00010000) == 0x00010000)) {
          sampleBasename_ = new com.google.protobuf.LazyStringArrayList(sampleBasename_);
          bitField0_ |= 0x00010000;
         }
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getSampleBasenameList() {
        return sampleBasename_.getUnmodifiableView();
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public int getSampleBasenameCount() {
        return sampleBasename_.size();
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public java.lang.String getSampleBasename(int index) {
        return sampleBasename_.get(index);
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public com.google.protobuf.ByteString
          getSampleBasenameBytes(int index) {
        return sampleBasename_.getByteString(index);
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public Builder setSampleBasename(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSampleBasenameIsMutable();
        sampleBasename_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public Builder addSampleBasename(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSampleBasenameIsMutable();
        sampleBasename_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public Builder addAllSampleBasename(
          java.lang.Iterable<java.lang.String> values) {
        ensureSampleBasenameIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, sampleBasename_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public Builder clearSampleBasename() {
        sampleBasename_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00010000);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string sample_basename = 30;</code>
       */
      public Builder addSampleBasenameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureSampleBasenameIsMutable();
        sampleBasename_.add(value);
        onChanged();
        return this;
      }

      private boolean queryIndicesWerePermuted_ ;
      /**
       * <code>optional bool query_indices_were_permuted = 26;</code>
       *
       * <pre>
       *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
       *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
       *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
       *instance), you will need the information in the permutation file (extension basename.perm) and transform back
       *each small index of interest to the original query index.
       * </pre>
       */
      public boolean hasQueryIndicesWerePermuted() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <code>optional bool query_indices_were_permuted = 26;</code>
       *
       * <pre>
       *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
       *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
       *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
       *instance), you will need the information in the permutation file (extension basename.perm) and transform back
       *each small index of interest to the original query index.
       * </pre>
       */
      public boolean getQueryIndicesWerePermuted() {
        return queryIndicesWerePermuted_;
      }
      /**
       * <code>optional bool query_indices_were_permuted = 26;</code>
       *
       * <pre>
       *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
       *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
       *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
       *instance), you will need the information in the permutation file (extension basename.perm) and transform back
       *each small index of interest to the original query index.
       * </pre>
       */
      public Builder setQueryIndicesWerePermuted(boolean value) {
        bitField0_ |= 0x00020000;
        queryIndicesWerePermuted_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool query_indices_were_permuted = 26;</code>
       *
       * <pre>
       *This field is true when the query indices of alignment entries were permuted to smaller indices. Only sorted
       *alignments can have query_indices_were_permuted=true. When the field is true, and you need to retrieve the
       *original query-index of an alignment (because you want to retrieve the specific read(s) from a read file for
       *instance), you will need the information in the permutation file (extension basename.perm) and transform back
       *each small index of interest to the original query index.
       * </pre>
       */
      public Builder clearQueryIndicesWerePermuted() {
        bitField0_ = (bitField0_ & ~0x00020000);
        queryIndicesWerePermuted_ = false;
        onChanged();
        return this;
      }

      private boolean queryIndexOccurrences_ ;
      /**
       * <code>optional bool query_index_occurrences = 35;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public boolean hasQueryIndexOccurrences() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <code>optional bool query_index_occurrences = 35;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public boolean getQueryIndexOccurrences() {
        return queryIndexOccurrences_;
      }
      /**
       * <code>optional bool query_index_occurrences = 35;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder setQueryIndexOccurrences(boolean value) {
        bitField0_ |= 0x00040000;
        queryIndexOccurrences_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool query_index_occurrences = 35;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the query_index_occurrences field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder clearQueryIndexOccurrences() {
        bitField0_ = (bitField0_ & ~0x00040000);
        queryIndexOccurrences_ = false;
        onChanged();
        return this;
      }

      private boolean ambiguityStoredInEntries_ ;
      /**
       * <code>optional bool ambiguity_stored_in_entries = 36;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the ambiguity field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public boolean hasAmbiguityStoredInEntries() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <code>optional bool ambiguity_stored_in_entries = 36;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the ambiguity field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public boolean getAmbiguityStoredInEntries() {
        return ambiguityStoredInEntries_;
      }
      /**
       * <code>optional bool ambiguity_stored_in_entries = 36;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the ambiguity field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder setAmbiguityStoredInEntries(boolean value) {
        bitField0_ |= 0x00080000;
        ambiguityStoredInEntries_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool ambiguity_stored_in_entries = 36;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the ambiguity field populated
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder clearAmbiguityStoredInEntries() {
        bitField0_ = (bitField0_ & ~0x00080000);
        ambiguityStoredInEntries_ = false;
        onChanged();
        return this;
      }

      private boolean allReadQualityScores_ ;
      /**
       * <code>optional bool all_read_quality_scores = 40;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
       *(Since Goby 2.0).
       * </pre>
       */
      public boolean hasAllReadQualityScores() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <code>optional bool all_read_quality_scores = 40;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
       *(Since Goby 2.0).
       * </pre>
       */
      public boolean getAllReadQualityScores() {
        return allReadQualityScores_;
      }
      /**
       * <code>optional bool all_read_quality_scores = 40;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder setAllReadQualityScores(boolean value) {
        bitField0_ |= 0x00100000;
        allReadQualityScores_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool all_read_quality_scores = 40;</code>
       *
       * <pre>
       *This field is true when entries in the alignment .entries file all have the read_quality_score field populated.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder clearAllReadQualityScores() {
        bitField0_ = (bitField0_ & ~0x00100000);
        allReadQualityScores_ = false;
        onChanged();
        return this;
      }

      private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo> readOrigin_ =
        java.util.Collections.emptyList();
      private void ensureReadOriginIsMutable() {
        if (!((bitField0_ & 0x00200000) == 0x00200000)) {
          readOrigin_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo>(readOrigin_);
          bitField0_ |= 0x00200000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder> readOriginBuilder_;

      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo> getReadOriginList() {
        if (readOriginBuilder_ == null) {
          return java.util.Collections.unmodifiableList(readOrigin_);
        } else {
          return readOriginBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public int getReadOriginCount() {
        if (readOriginBuilder_ == null) {
          return readOrigin_.size();
        } else {
          return readOriginBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo getReadOrigin(int index) {
        if (readOriginBuilder_ == null) {
          return readOrigin_.get(index);
        } else {
          return readOriginBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder setReadOrigin(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo value) {
        if (readOriginBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReadOriginIsMutable();
          readOrigin_.set(index, value);
          onChanged();
        } else {
          readOriginBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder setReadOrigin(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder builderForValue) {
        if (readOriginBuilder_ == null) {
          ensureReadOriginIsMutable();
          readOrigin_.set(index, builderForValue.build());
          onChanged();
        } else {
          readOriginBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder addReadOrigin(edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo value) {
        if (readOriginBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReadOriginIsMutable();
          readOrigin_.add(value);
          onChanged();
        } else {
          readOriginBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder addReadOrigin(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo value) {
        if (readOriginBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureReadOriginIsMutable();
          readOrigin_.add(index, value);
          onChanged();
        } else {
          readOriginBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder addReadOrigin(
          edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder builderForValue) {
        if (readOriginBuilder_ == null) {
          ensureReadOriginIsMutable();
          readOrigin_.add(builderForValue.build());
          onChanged();
        } else {
          readOriginBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder addReadOrigin(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder builderForValue) {
        if (readOriginBuilder_ == null) {
          ensureReadOriginIsMutable();
          readOrigin_.add(index, builderForValue.build());
          onChanged();
        } else {
          readOriginBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder addAllReadOrigin(
          java.lang.Iterable<? extends edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo> values) {
        if (readOriginBuilder_ == null) {
          ensureReadOriginIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, readOrigin_);
          onChanged();
        } else {
          readOriginBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder clearReadOrigin() {
        if (readOriginBuilder_ == null) {
          readOrigin_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00200000);
          onChanged();
        } else {
          readOriginBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public Builder removeReadOrigin(int index) {
        if (readOriginBuilder_ == null) {
          ensureReadOriginIsMutable();
          readOrigin_.remove(index);
          onChanged();
        } else {
          readOriginBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder getReadOriginBuilder(
          int index) {
        return getReadOriginFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder getReadOriginOrBuilder(
          int index) {
        if (readOriginBuilder_ == null) {
          return readOrigin_.get(index);  } else {
          return readOriginBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder> 
           getReadOriginOrBuilderList() {
        if (readOriginBuilder_ != null) {
          return readOriginBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(readOrigin_);
        }
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder addReadOriginBuilder() {
        return getReadOriginFieldBuilder().addBuilder(
            edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder addReadOriginBuilder(
          int index) {
        return getReadOriginFieldBuilder().addBuilder(
            index, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.ReadOriginInfo read_origin = 27;</code>
       *
       * <pre>
       *A description of the origin of sets of reads. Serves a similar function to BAM read groups, but more flexible and
       *efficient. Instead of storing strings, we use integers in the entries.
       *Alignemnt entries will link to a specific ReadOriginInfo with the origin_index field.
       *(Since Goby 2.0).
       * </pre>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder> 
           getReadOriginBuilderList() {
        return getReadOriginFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder> 
          getReadOriginFieldBuilder() {
        if (readOriginBuilder_ == null) {
          readOriginBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder>(
                  readOrigin_,
                  ((bitField0_ & 0x00200000) == 0x00200000),
                  getParentForChildren(),
                  isClean());
          readOrigin_ = null;
        }
        return readOriginBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:goby.AlignmentHeader)
    }

    static {
      defaultInstance = new AlignmentHeader(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.AlignmentHeader)
  }

  public interface IdentifierMappingOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.IdentifierMapping)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo> 
        getMappingsList();
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo getMappings(int index);
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    int getMappingsCount();
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder> 
        getMappingsOrBuilderList();
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder getMappingsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code goby.IdentifierMapping}
   */
  public static final class IdentifierMapping extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.IdentifierMapping)
      IdentifierMappingOrBuilder {
    // Use IdentifierMapping.newBuilder() to construct.
    private IdentifierMapping(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private IdentifierMapping(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final IdentifierMapping defaultInstance;
    public static IdentifierMapping getDefaultInstance() {
      return defaultInstance;
    }

    public IdentifierMapping getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private IdentifierMapping(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                mappings_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo>();
                mutable_bitField0_ |= 0x00000001;
              }
              mappings_.add(input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.PARSER, extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          mappings_ = java.util.Collections.unmodifiableList(mappings_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierMapping_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierMapping_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.class, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder.class);
    }

    public static com.google.protobuf.Parser<IdentifierMapping> PARSER =
        new com.google.protobuf.AbstractParser<IdentifierMapping>() {
      public IdentifierMapping parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new IdentifierMapping(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<IdentifierMapping> getParserForType() {
      return PARSER;
    }

    public static final int MAPPINGS_FIELD_NUMBER = 1;
    private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo> mappings_;
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo> getMappingsList() {
      return mappings_;
    }
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder> 
        getMappingsOrBuilderList() {
      return mappings_;
    }
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    public int getMappingsCount() {
      return mappings_.size();
    }
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo getMappings(int index) {
      return mappings_.get(index);
    }
    /**
     * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder getMappingsOrBuilder(
        int index) {
      return mappings_.get(index);
    }

    private void initFields() {
      mappings_ = java.util.Collections.emptyList();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getMappingsCount(); i++) {
        if (!getMappings(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      for (int i = 0; i < mappings_.size(); i++) {
        output.writeMessage(1, mappings_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < mappings_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, mappings_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.IdentifierMapping}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.IdentifierMapping)
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMappingOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierMapping_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierMapping_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.class, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getMappingsFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        if (mappingsBuilder_ == null) {
          mappings_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          mappingsBuilder_.clear();
        }
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierMapping_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping build() {
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping result = new edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping(this);
        int from_bitField0_ = bitField0_;
        if (mappingsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            mappings_ = java.util.Collections.unmodifiableList(mappings_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.mappings_ = mappings_;
        } else {
          result.mappings_ = mappingsBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping.getDefaultInstance()) return this;
        if (mappingsBuilder_ == null) {
          if (!other.mappings_.isEmpty()) {
            if (mappings_.isEmpty()) {
              mappings_ = other.mappings_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureMappingsIsMutable();
              mappings_.addAll(other.mappings_);
            }
            onChanged();
          }
        } else {
          if (!other.mappings_.isEmpty()) {
            if (mappingsBuilder_.isEmpty()) {
              mappingsBuilder_.dispose();
              mappingsBuilder_ = null;
              mappings_ = other.mappings_;
              bitField0_ = (bitField0_ & ~0x00000001);
              mappingsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getMappingsFieldBuilder() : null;
            } else {
              mappingsBuilder_.addAllMessages(other.mappings_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        for (int i = 0; i < getMappingsCount(); i++) {
          if (!getMappings(i).isInitialized()) {
            
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.IdentifierMapping) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo> mappings_ =
        java.util.Collections.emptyList();
      private void ensureMappingsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          mappings_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo>(mappings_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder> mappingsBuilder_;

      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo> getMappingsList() {
        if (mappingsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(mappings_);
        } else {
          return mappingsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public int getMappingsCount() {
        if (mappingsBuilder_ == null) {
          return mappings_.size();
        } else {
          return mappingsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo getMappings(int index) {
        if (mappingsBuilder_ == null) {
          return mappings_.get(index);
        } else {
          return mappingsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder setMappings(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo value) {
        if (mappingsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMappingsIsMutable();
          mappings_.set(index, value);
          onChanged();
        } else {
          mappingsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder setMappings(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder builderForValue) {
        if (mappingsBuilder_ == null) {
          ensureMappingsIsMutable();
          mappings_.set(index, builderForValue.build());
          onChanged();
        } else {
          mappingsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder addMappings(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo value) {
        if (mappingsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMappingsIsMutable();
          mappings_.add(value);
          onChanged();
        } else {
          mappingsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder addMappings(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo value) {
        if (mappingsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMappingsIsMutable();
          mappings_.add(index, value);
          onChanged();
        } else {
          mappingsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder addMappings(
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder builderForValue) {
        if (mappingsBuilder_ == null) {
          ensureMappingsIsMutable();
          mappings_.add(builderForValue.build());
          onChanged();
        } else {
          mappingsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder addMappings(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder builderForValue) {
        if (mappingsBuilder_ == null) {
          ensureMappingsIsMutable();
          mappings_.add(index, builderForValue.build());
          onChanged();
        } else {
          mappingsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder addAllMappings(
          java.lang.Iterable<? extends edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo> values) {
        if (mappingsBuilder_ == null) {
          ensureMappingsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, mappings_);
          onChanged();
        } else {
          mappingsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder clearMappings() {
        if (mappingsBuilder_ == null) {
          mappings_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          mappingsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public Builder removeMappings(int index) {
        if (mappingsBuilder_ == null) {
          ensureMappingsIsMutable();
          mappings_.remove(index);
          onChanged();
        } else {
          mappingsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder getMappingsBuilder(
          int index) {
        return getMappingsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder getMappingsOrBuilder(
          int index) {
        if (mappingsBuilder_ == null) {
          return mappings_.get(index);  } else {
          return mappingsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder> 
           getMappingsOrBuilderList() {
        if (mappingsBuilder_ != null) {
          return mappingsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(mappings_);
        }
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder addMappingsBuilder() {
        return getMappingsFieldBuilder().addBuilder(
            edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder addMappingsBuilder(
          int index) {
        return getMappingsFieldBuilder().addBuilder(
            index, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.IdentifierInfo mappings = 1;</code>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder> 
           getMappingsBuilderList() {
        return getMappingsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder> 
          getMappingsFieldBuilder() {
        if (mappingsBuilder_ == null) {
          mappingsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder>(
                  mappings_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          mappings_ = null;
        }
        return mappingsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:goby.IdentifierMapping)
    }

    static {
      defaultInstance = new IdentifierMapping(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.IdentifierMapping)
  }

  public interface IdentifierInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.IdentifierInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required string name = 1;</code>
     */
    boolean hasName();
    /**
     * <code>required string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <code>required string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>required uint32 index = 2;</code>
     */
    boolean hasIndex();
    /**
     * <code>required uint32 index = 2;</code>
     */
    int getIndex();
  }
  /**
   * Protobuf type {@code goby.IdentifierInfo}
   */
  public static final class IdentifierInfo extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.IdentifierInfo)
      IdentifierInfoOrBuilder {
    // Use IdentifierInfo.newBuilder() to construct.
    private IdentifierInfo(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private IdentifierInfo(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final IdentifierInfo defaultInstance;
    public static IdentifierInfo getDefaultInstance() {
      return defaultInstance;
    }

    public IdentifierInfo getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private IdentifierInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              index_ = input.readUInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierInfo_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.class, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder.class);
    }

    public static com.google.protobuf.Parser<IdentifierInfo> PARSER =
        new com.google.protobuf.AbstractParser<IdentifierInfo>() {
      public IdentifierInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new IdentifierInfo(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<IdentifierInfo> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private java.lang.Object name_;
    /**
     * <code>required string name = 1;</code>
     */
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <code>required string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INDEX_FIELD_NUMBER = 2;
    private int index_;
    /**
     * <code>required uint32 index = 2;</code>
     */
    public boolean hasIndex() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required uint32 index = 2;</code>
     */
    public int getIndex() {
      return index_;
    }

    private void initFields() {
      name_ = "";
      index_ = 0;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasIndex()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getNameBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(2, index_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, getNameBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, index_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.IdentifierInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.IdentifierInfo)
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierInfo_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.class, edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        index_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_IdentifierInfo_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo build() {
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo result = new edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.index_ = index_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasIndex()) {
          setIndex(other.getIndex());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (!hasName()) {
          
          return false;
        }
        if (!hasIndex()) {
          
          return false;
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.IdentifierInfo) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <code>required string name = 1;</code>
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>required string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>required string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required string name = 1;</code>
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <code>required string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private int index_ ;
      /**
       * <code>required uint32 index = 2;</code>
       */
      public boolean hasIndex() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>required uint32 index = 2;</code>
       */
      public int getIndex() {
        return index_;
      }
      /**
       * <code>required uint32 index = 2;</code>
       */
      public Builder setIndex(int value) {
        bitField0_ |= 0x00000002;
        index_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required uint32 index = 2;</code>
       */
      public Builder clearIndex() {
        bitField0_ = (bitField0_ & ~0x00000002);
        index_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:goby.IdentifierInfo)
    }

    static {
      defaultInstance = new IdentifierInfo(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.IdentifierInfo)
  }

  public interface ReadOriginInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.ReadOriginInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required uint32 origin_index = 1;</code>
     *
     * <pre>
     *Origin index. An integer that links alignment entries to their origin information.
     * </pre>
     */
    boolean hasOriginIndex();
    /**
     * <code>required uint32 origin_index = 1;</code>
     *
     * <pre>
     *Origin index. An integer that links alignment entries to their origin information.
     * </pre>
     */
    int getOriginIndex();

    /**
     * <code>required string origin_id = 2;</code>
     *
     * <pre>
     *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
     *groups. Free text.
     * </pre>
     */
    boolean hasOriginId();
    /**
     * <code>required string origin_id = 2;</code>
     *
     * <pre>
     *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
     *groups. Free text.
     * </pre>
     */
    java.lang.String getOriginId();
    /**
     * <code>required string origin_id = 2;</code>
     *
     * <pre>
     *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
     *groups. Free text.
     * </pre>
     */
    com.google.protobuf.ByteString
        getOriginIdBytes();

    /**
     * <code>optional string sample = 4;</code>
     *
     * <pre>
     *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
     *groups. Free text.
     * </pre>
     */
    boolean hasSample();
    /**
     * <code>optional string sample = 4;</code>
     *
     * <pre>
     *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
     *groups. Free text.
     * </pre>
     */
    java.lang.String getSample();
    /**
     * <code>optional string sample = 4;</code>
     *
     * <pre>
     *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
     *groups. Free text.
     * </pre>
     */
    com.google.protobuf.ByteString
        getSampleBytes();

    /**
     * <code>optional string platform = 5;</code>
     *
     * <pre>
     *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
     *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
     * </pre>
     */
    boolean hasPlatform();
    /**
     * <code>optional string platform = 5;</code>
     *
     * <pre>
     *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
     *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
     * </pre>
     */
    java.lang.String getPlatform();
    /**
     * <code>optional string platform = 5;</code>
     *
     * <pre>
     *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
     *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
     * </pre>
     */
    com.google.protobuf.ByteString
        getPlatformBytes();

    /**
     * <code>optional string library = 8;</code>
     *
     * <pre>
     *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
     *groups. Free text.
     * </pre>
     */
    boolean hasLibrary();
    /**
     * <code>optional string library = 8;</code>
     *
     * <pre>
     *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
     *groups. Free text.
     * </pre>
     */
    java.lang.String getLibrary();
    /**
     * <code>optional string library = 8;</code>
     *
     * <pre>
     *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
     *groups. Free text.
     * </pre>
     */
    com.google.protobuf.ByteString
        getLibraryBytes();

    /**
     * <code>optional string platform_unit = 12;</code>
     *
     * <pre>
     *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
     * </pre>
     */
    boolean hasPlatformUnit();
    /**
     * <code>optional string platform_unit = 12;</code>
     *
     * <pre>
     *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
     * </pre>
     */
    java.lang.String getPlatformUnit();
    /**
     * <code>optional string platform_unit = 12;</code>
     *
     * <pre>
     *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
     * </pre>
     */
    com.google.protobuf.ByteString
        getPlatformUnitBytes();

    /**
     * <code>optional string run_date = 6;</code>
     *
     * <pre>
     *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
     *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
     * </pre>
     */
    boolean hasRunDate();
    /**
     * <code>optional string run_date = 6;</code>
     *
     * <pre>
     *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
     *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
     * </pre>
     */
    java.lang.String getRunDate();
    /**
     * <code>optional string run_date = 6;</code>
     *
     * <pre>
     *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
     *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
     * </pre>
     */
    com.google.protobuf.ByteString
        getRunDateBytes();
  }
  /**
   * Protobuf type {@code goby.ReadOriginInfo}
   *
   * <pre>
   *A description of the origin of sets of reads. Stored in the Goby alignment header and linked
   *from alignment entries. Goby makes it possible to adapt origin equivalence rules on the fly
   *efficiently. To do this, it is sufficient to read the header of the alignment, decide which
   *ReadOriginInfo instances are equivalent (e.g., by looking at sample, platform, library, or
   *other fields in the message), then construct a function e(a):int. This function takes
   *one originIndex parameter and returns another integer that maps to an equivalent class. The
   *equivalence class can be used to estimate error models for entries that belong to each class,
   *for instance.
   *(Since Goby 2.0).
   * </pre>
   */
  public static final class ReadOriginInfo extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.ReadOriginInfo)
      ReadOriginInfoOrBuilder {
    // Use ReadOriginInfo.newBuilder() to construct.
    private ReadOriginInfo(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private ReadOriginInfo(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final ReadOriginInfo defaultInstance;
    public static ReadOriginInfo getDefaultInstance() {
      return defaultInstance;
    }

    public ReadOriginInfo getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private ReadOriginInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000001;
              originIndex_ = input.readUInt32();
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              originId_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              sample_ = bs;
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              platform_ = bs;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000040;
              runDate_ = bs;
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000010;
              library_ = bs;
              break;
            }
            case 98: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000020;
              platformUnit_ = bs;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_ReadOriginInfo_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_ReadOriginInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.class, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder.class);
    }

    public static com.google.protobuf.Parser<ReadOriginInfo> PARSER =
        new com.google.protobuf.AbstractParser<ReadOriginInfo>() {
      public ReadOriginInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ReadOriginInfo(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<ReadOriginInfo> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int ORIGIN_INDEX_FIELD_NUMBER = 1;
    private int originIndex_;
    /**
     * <code>required uint32 origin_index = 1;</code>
     *
     * <pre>
     *Origin index. An integer that links alignment entries to their origin information.
     * </pre>
     */
    public boolean hasOriginIndex() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required uint32 origin_index = 1;</code>
     *
     * <pre>
     *Origin index. An integer that links alignment entries to their origin information.
     * </pre>
     */
    public int getOriginIndex() {
      return originIndex_;
    }

    public static final int ORIGIN_ID_FIELD_NUMBER = 2;
    private java.lang.Object originId_;
    /**
     * <code>required string origin_id = 2;</code>
     *
     * <pre>
     *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
     *groups. Free text.
     * </pre>
     */
    public boolean hasOriginId() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required string origin_id = 2;</code>
     *
     * <pre>
     *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
     *groups. Free text.
     * </pre>
     */
    public java.lang.String getOriginId() {
      java.lang.Object ref = originId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          originId_ = s;
        }
        return s;
      }
    }
    /**
     * <code>required string origin_id = 2;</code>
     *
     * <pre>
     *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
     *groups. Free text.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getOriginIdBytes() {
      java.lang.Object ref = originId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        originId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SAMPLE_FIELD_NUMBER = 4;
    private java.lang.Object sample_;
    /**
     * <code>optional string sample = 4;</code>
     *
     * <pre>
     *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
     *groups. Free text.
     * </pre>
     */
    public boolean hasSample() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional string sample = 4;</code>
     *
     * <pre>
     *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
     *groups. Free text.
     * </pre>
     */
    public java.lang.String getSample() {
      java.lang.Object ref = sample_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          sample_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string sample = 4;</code>
     *
     * <pre>
     *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
     *groups. Free text.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getSampleBytes() {
      java.lang.Object ref = sample_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sample_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PLATFORM_FIELD_NUMBER = 5;
    private java.lang.Object platform_;
    /**
     * <code>optional string platform = 5;</code>
     *
     * <pre>
     *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
     *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
     * </pre>
     */
    public boolean hasPlatform() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional string platform = 5;</code>
     *
     * <pre>
     *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
     *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
     * </pre>
     */
    public java.lang.String getPlatform() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          platform_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string platform = 5;</code>
     *
     * <pre>
     *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
     *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPlatformBytes() {
      java.lang.Object ref = platform_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        platform_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LIBRARY_FIELD_NUMBER = 8;
    private java.lang.Object library_;
    /**
     * <code>optional string library = 8;</code>
     *
     * <pre>
     *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
     *groups. Free text.
     * </pre>
     */
    public boolean hasLibrary() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional string library = 8;</code>
     *
     * <pre>
     *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
     *groups. Free text.
     * </pre>
     */
    public java.lang.String getLibrary() {
      java.lang.Object ref = library_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          library_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string library = 8;</code>
     *
     * <pre>
     *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
     *groups. Free text.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getLibraryBytes() {
      java.lang.Object ref = library_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        library_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PLATFORM_UNIT_FIELD_NUMBER = 12;
    private java.lang.Object platformUnit_;
    /**
     * <code>optional string platform_unit = 12;</code>
     *
     * <pre>
     *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
     * </pre>
     */
    public boolean hasPlatformUnit() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional string platform_unit = 12;</code>
     *
     * <pre>
     *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
     * </pre>
     */
    public java.lang.String getPlatformUnit() {
      java.lang.Object ref = platformUnit_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          platformUnit_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string platform_unit = 12;</code>
     *
     * <pre>
     *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPlatformUnitBytes() {
      java.lang.Object ref = platformUnit_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        platformUnit_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RUN_DATE_FIELD_NUMBER = 6;
    private java.lang.Object runDate_;
    /**
     * <code>optional string run_date = 6;</code>
     *
     * <pre>
     *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
     *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
     * </pre>
     */
    public boolean hasRunDate() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional string run_date = 6;</code>
     *
     * <pre>
     *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
     *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
     * </pre>
     */
    public java.lang.String getRunDate() {
      java.lang.Object ref = runDate_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          runDate_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string run_date = 6;</code>
     *
     * <pre>
     *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
     *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getRunDateBytes() {
      java.lang.Object ref = runDate_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        runDate_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private void initFields() {
      originIndex_ = 0;
      originId_ = "";
      sample_ = "";
      platform_ = "";
      library_ = "";
      platformUnit_ = "";
      runDate_ = "";
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasOriginIndex()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasOriginId()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(1, originIndex_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, getOriginIdBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(4, getSampleBytes());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBytes(5, getPlatformBytes());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeBytes(6, getRunDateBytes());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBytes(8, getLibraryBytes());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeBytes(12, getPlatformUnitBytes());
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, originIndex_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, getOriginIdBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, getSampleBytes());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, getPlatformBytes());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(6, getRunDateBytes());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(8, getLibraryBytes());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(12, getPlatformUnitBytes());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.ReadOriginInfo}
     *
     * <pre>
     *A description of the origin of sets of reads. Stored in the Goby alignment header and linked
     *from alignment entries. Goby makes it possible to adapt origin equivalence rules on the fly
     *efficiently. To do this, it is sufficient to read the header of the alignment, decide which
     *ReadOriginInfo instances are equivalent (e.g., by looking at sample, platform, library, or
     *other fields in the message), then construct a function e(a):int. This function takes
     *one originIndex parameter and returns another integer that maps to an equivalent class. The
     *equivalence class can be used to estimate error models for entries that belong to each class,
     *for instance.
     *(Since Goby 2.0).
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.ReadOriginInfo)
        edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_ReadOriginInfo_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_ReadOriginInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.class, edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        originIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        originId_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        sample_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        platform_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        library_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        platformUnit_ = "";
        bitField0_ = (bitField0_ & ~0x00000020);
        runDate_ = "";
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_ReadOriginInfo_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo build() {
        edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo result = new edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.originIndex_ = originIndex_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.originId_ = originId_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.sample_ = sample_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.platform_ = platform_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.library_ = library_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.platformUnit_ = platformUnit_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.runDate_ = runDate_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo.getDefaultInstance()) return this;
        if (other.hasOriginIndex()) {
          setOriginIndex(other.getOriginIndex());
        }
        if (other.hasOriginId()) {
          bitField0_ |= 0x00000002;
          originId_ = other.originId_;
          onChanged();
        }
        if (other.hasSample()) {
          bitField0_ |= 0x00000004;
          sample_ = other.sample_;
          onChanged();
        }
        if (other.hasPlatform()) {
          bitField0_ |= 0x00000008;
          platform_ = other.platform_;
          onChanged();
        }
        if (other.hasLibrary()) {
          bitField0_ |= 0x00000010;
          library_ = other.library_;
          onChanged();
        }
        if (other.hasPlatformUnit()) {
          bitField0_ |= 0x00000020;
          platformUnit_ = other.platformUnit_;
          onChanged();
        }
        if (other.hasRunDate()) {
          bitField0_ |= 0x00000040;
          runDate_ = other.runDate_;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (!hasOriginIndex()) {
          
          return false;
        }
        if (!hasOriginId()) {
          
          return false;
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.ReadOriginInfo) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int originIndex_ ;
      /**
       * <code>required uint32 origin_index = 1;</code>
       *
       * <pre>
       *Origin index. An integer that links alignment entries to their origin information.
       * </pre>
       */
      public boolean hasOriginIndex() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required uint32 origin_index = 1;</code>
       *
       * <pre>
       *Origin index. An integer that links alignment entries to their origin information.
       * </pre>
       */
      public int getOriginIndex() {
        return originIndex_;
      }
      /**
       * <code>required uint32 origin_index = 1;</code>
       *
       * <pre>
       *Origin index. An integer that links alignment entries to their origin information.
       * </pre>
       */
      public Builder setOriginIndex(int value) {
        bitField0_ |= 0x00000001;
        originIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required uint32 origin_index = 1;</code>
       *
       * <pre>
       *Origin index. An integer that links alignment entries to their origin information.
       * </pre>
       */
      public Builder clearOriginIndex() {
        bitField0_ = (bitField0_ & ~0x00000001);
        originIndex_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object originId_ = "";
      /**
       * <code>required string origin_id = 2;</code>
       *
       * <pre>
       *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
       *groups. Free text.
       * </pre>
       */
      public boolean hasOriginId() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>required string origin_id = 2;</code>
       *
       * <pre>
       *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
       *groups. Free text.
       * </pre>
       */
      public java.lang.String getOriginId() {
        java.lang.Object ref = originId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            originId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>required string origin_id = 2;</code>
       *
       * <pre>
       *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
       *groups. Free text.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getOriginIdBytes() {
        java.lang.Object ref = originId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          originId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>required string origin_id = 2;</code>
       *
       * <pre>
       *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder setOriginId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        originId_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required string origin_id = 2;</code>
       *
       * <pre>
       *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder clearOriginId() {
        bitField0_ = (bitField0_ & ~0x00000002);
        originId_ = getDefaultInstance().getOriginId();
        onChanged();
        return this;
      }
      /**
       * <code>required string origin_id = 2;</code>
       *
       * <pre>
       *Identifier that describes the origin of the reads. This field is compatible with the ID/platform field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder setOriginIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        originId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object sample_ = "";
      /**
       * <code>optional string sample = 4;</code>
       *
       * <pre>
       *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
       *groups. Free text.
       * </pre>
       */
      public boolean hasSample() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional string sample = 4;</code>
       *
       * <pre>
       *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
       *groups. Free text.
       * </pre>
       */
      public java.lang.String getSample() {
        java.lang.Object ref = sample_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sample_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string sample = 4;</code>
       *
       * <pre>
       *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
       *groups. Free text.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getSampleBytes() {
        java.lang.Object ref = sample_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sample_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string sample = 4;</code>
       *
       * <pre>
       *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder setSample(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        sample_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string sample = 4;</code>
       *
       * <pre>
       *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder clearSample() {
        bitField0_ = (bitField0_ & ~0x00000004);
        sample_ = getDefaultInstance().getSample();
        onChanged();
        return this;
      }
      /**
       * <code>optional string sample = 4;</code>
       *
       * <pre>
       *The sample from which the reads were sequenced. This field is compatible with the SM/sample field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder setSampleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        sample_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object platform_ = "";
      /**
       * <code>optional string platform = 5;</code>
       *
       * <pre>
       *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
       *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
       * </pre>
       */
      public boolean hasPlatform() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional string platform = 5;</code>
       *
       * <pre>
       *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
       *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
       * </pre>
       */
      public java.lang.String getPlatform() {
        java.lang.Object ref = platform_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            platform_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string platform = 5;</code>
       *
       * <pre>
       *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
       *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPlatformBytes() {
        java.lang.Object ref = platform_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          platform_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string platform = 5;</code>
       *
       * <pre>
       *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
       *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
       * </pre>
       */
      public Builder setPlatform(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        platform_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string platform = 5;</code>
       *
       * <pre>
       *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
       *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
       * </pre>
       */
      public Builder clearPlatform() {
        bitField0_ = (bitField0_ & ~0x00000008);
        platform_ = getDefaultInstance().getPlatform();
        onChanged();
        return this;
      }
      /**
       * <code>optional string platform = 5;</code>
       *
       * <pre>
       *The platform on which the reads were sequenced. This field is compatible with the PL/platform field of BAM read
       *groups. Valid values: ILLUMINA, SOLID, LS454, HELICOS and PACBIO.
       * </pre>
       */
      public Builder setPlatformBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        platform_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object library_ = "";
      /**
       * <code>optional string library = 8;</code>
       *
       * <pre>
       *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
       *groups. Free text.
       * </pre>
       */
      public boolean hasLibrary() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional string library = 8;</code>
       *
       * <pre>
       *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
       *groups. Free text.
       * </pre>
       */
      public java.lang.String getLibrary() {
        java.lang.Object ref = library_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            library_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string library = 8;</code>
       *
       * <pre>
       *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
       *groups. Free text.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getLibraryBytes() {
        java.lang.Object ref = library_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          library_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string library = 8;</code>
       *
       * <pre>
       *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder setLibrary(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        library_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string library = 8;</code>
       *
       * <pre>
       *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder clearLibrary() {
        bitField0_ = (bitField0_ & ~0x00000010);
        library_ = getDefaultInstance().getLibrary();
        onChanged();
        return this;
      }
      /**
       * <code>optional string library = 8;</code>
       *
       * <pre>
       *The library from which the reads were sequenced. This field is compatible with the LB/library field of BAM read
       *groups. Free text.
       * </pre>
       */
      public Builder setLibraryBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        library_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object platformUnit_ = "";
      /**
       * <code>optional string platform_unit = 12;</code>
       *
       * <pre>
       *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
       * </pre>
       */
      public boolean hasPlatformUnit() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional string platform_unit = 12;</code>
       *
       * <pre>
       *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
       * </pre>
       */
      public java.lang.String getPlatformUnit() {
        java.lang.Object ref = platformUnit_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            platformUnit_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string platform_unit = 12;</code>
       *
       * <pre>
       *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPlatformUnitBytes() {
        java.lang.Object ref = platformUnit_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          platformUnit_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string platform_unit = 12;</code>
       *
       * <pre>
       *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
       * </pre>
       */
      public Builder setPlatformUnit(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        platformUnit_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string platform_unit = 12;</code>
       *
       * <pre>
       *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
       * </pre>
       */
      public Builder clearPlatformUnit() {
        bitField0_ = (bitField0_ & ~0x00000020);
        platformUnit_ = getDefaultInstance().getPlatformUnit();
        onChanged();
        return this;
      }
      /**
       * <code>optional string platform_unit = 12;</code>
       *
       * <pre>
       *The platform unit on which the reads were sequenced. This field for compatibility with samtools.
       * </pre>
       */
      public Builder setPlatformUnitBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        platformUnit_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object runDate_ = "";
      /**
       * <code>optional string run_date = 6;</code>
       *
       * <pre>
       *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
       *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
       * </pre>
       */
      public boolean hasRunDate() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional string run_date = 6;</code>
       *
       * <pre>
       *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
       *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
       * </pre>
       */
      public java.lang.String getRunDate() {
        java.lang.Object ref = runDate_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            runDate_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string run_date = 6;</code>
       *
       * <pre>
       *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
       *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getRunDateBytes() {
        java.lang.Object ref = runDate_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          runDate_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string run_date = 6;</code>
       *
       * <pre>
       *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
       *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
       * </pre>
       */
      public Builder setRunDate(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        runDate_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string run_date = 6;</code>
       *
       * <pre>
       *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
       *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
       * </pre>
       */
      public Builder clearRunDate() {
        bitField0_ = (bitField0_ & ~0x00000040);
        runDate_ = getDefaultInstance().getRunDate();
        onChanged();
        return this;
      }
      /**
       * <code>optional string run_date = 6;</code>
       *
       * <pre>
       *The date the reads were sequenced. Useful to identify batch effects, in the format dd:MMM:yyyy.
       *The month is Jan, Feb, etc. to avoid all confusion with days when day&lt;=12.
       * </pre>
       */
      public Builder setRunDateBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        runDate_ = value;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:goby.ReadOriginInfo)
    }

    static {
      defaultInstance = new ReadOriginInfo(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.ReadOriginInfo)
  }

  public interface AlignmentTooManyHitsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.AlignmentTooManyHits)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required uint32 aligner_threshold = 2;</code>
     *
     * <pre>
     *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
     *Referred to as parameter k below.
     * </pre>
     */
    boolean hasAlignerThreshold();
    /**
     * <code>required uint32 aligner_threshold = 2;</code>
     *
     * <pre>
     *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
     *Referred to as parameter k below.
     * </pre>
     */
    int getAlignerThreshold();

    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation> 
        getHitsList();
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation getHits(int index);
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    int getHitsCount();
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder> 
        getHitsOrBuilderList();
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder getHitsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code goby.AlignmentTooManyHits}
   */
  public static final class AlignmentTooManyHits extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.AlignmentTooManyHits)
      AlignmentTooManyHitsOrBuilder {
    // Use AlignmentTooManyHits.newBuilder() to construct.
    private AlignmentTooManyHits(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private AlignmentTooManyHits(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final AlignmentTooManyHits defaultInstance;
    public static AlignmentTooManyHits getDefaultInstance() {
      return defaultInstance;
    }

    public AlignmentTooManyHits getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private AlignmentTooManyHits(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                hits_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation>();
                mutable_bitField0_ |= 0x00000002;
              }
              hits_.add(input.readMessage(edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.PARSER, extensionRegistry));
              break;
            }
            case 16: {
              bitField0_ |= 0x00000001;
              alignerThreshold_ = input.readUInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          hits_ = java.util.Collections.unmodifiableList(hits_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentTooManyHits_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentTooManyHits_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits.Builder.class);
    }

    public static com.google.protobuf.Parser<AlignmentTooManyHits> PARSER =
        new com.google.protobuf.AbstractParser<AlignmentTooManyHits>() {
      public AlignmentTooManyHits parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AlignmentTooManyHits(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<AlignmentTooManyHits> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int ALIGNER_THRESHOLD_FIELD_NUMBER = 2;
    private int alignerThreshold_;
    /**
     * <code>required uint32 aligner_threshold = 2;</code>
     *
     * <pre>
     *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
     *Referred to as parameter k below.
     * </pre>
     */
    public boolean hasAlignerThreshold() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required uint32 aligner_threshold = 2;</code>
     *
     * <pre>
     *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
     *Referred to as parameter k below.
     * </pre>
     */
    public int getAlignerThreshold() {
      return alignerThreshold_;
    }

    public static final int HITS_FIELD_NUMBER = 1;
    private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation> hits_;
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation> getHitsList() {
      return hits_;
    }
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder> 
        getHitsOrBuilderList() {
      return hits_;
    }
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    public int getHitsCount() {
      return hits_.size();
    }
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation getHits(int index) {
      return hits_.get(index);
    }
    /**
     * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
     *
     * <pre>
     *The hits that are assigned to several (&gt;k) reference location.
     * </pre>
     */
    public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder getHitsOrBuilder(
        int index) {
      return hits_.get(index);
    }

    private void initFields() {
      alignerThreshold_ = 0;
      hits_ = java.util.Collections.emptyList();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasAlignerThreshold()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getHitsCount(); i++) {
        if (!getHits(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      for (int i = 0; i < hits_.size(); i++) {
        output.writeMessage(1, hits_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(2, alignerThreshold_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < hits_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, hits_.get(i));
      }
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, alignerThreshold_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.AlignmentTooManyHits}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.AlignmentTooManyHits)
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHitsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentTooManyHits_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentTooManyHits_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getHitsFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        alignerThreshold_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (hitsBuilder_ == null) {
          hits_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          hitsBuilder_.clear();
        }
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentTooManyHits_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits build() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits result = new edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.alignerThreshold_ = alignerThreshold_;
        if (hitsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            hits_ = java.util.Collections.unmodifiableList(hits_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.hits_ = hits_;
        } else {
          result.hits_ = hitsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits.getDefaultInstance()) return this;
        if (other.hasAlignerThreshold()) {
          setAlignerThreshold(other.getAlignerThreshold());
        }
        if (hitsBuilder_ == null) {
          if (!other.hits_.isEmpty()) {
            if (hits_.isEmpty()) {
              hits_ = other.hits_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureHitsIsMutable();
              hits_.addAll(other.hits_);
            }
            onChanged();
          }
        } else {
          if (!other.hits_.isEmpty()) {
            if (hitsBuilder_.isEmpty()) {
              hitsBuilder_.dispose();
              hitsBuilder_ = null;
              hits_ = other.hits_;
              bitField0_ = (bitField0_ & ~0x00000002);
              hitsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getHitsFieldBuilder() : null;
            } else {
              hitsBuilder_.addAllMessages(other.hits_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (!hasAlignerThreshold()) {
          
          return false;
        }
        for (int i = 0; i < getHitsCount(); i++) {
          if (!getHits(i).isInitialized()) {
            
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.AlignmentTooManyHits) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int alignerThreshold_ ;
      /**
       * <code>required uint32 aligner_threshold = 2;</code>
       *
       * <pre>
       *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
       *Referred to as parameter k below.
       * </pre>
       */
      public boolean hasAlignerThreshold() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required uint32 aligner_threshold = 2;</code>
       *
       * <pre>
       *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
       *Referred to as parameter k below.
       * </pre>
       */
      public int getAlignerThreshold() {
        return alignerThreshold_;
      }
      /**
       * <code>required uint32 aligner_threshold = 2;</code>
       *
       * <pre>
       *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
       *Referred to as parameter k below.
       * </pre>
       */
      public Builder setAlignerThreshold(int value) {
        bitField0_ |= 0x00000001;
        alignerThreshold_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required uint32 aligner_threshold = 2;</code>
       *
       * <pre>
       *The threshold used by the aligner to determine that a query is ambiguous and should be dropped.
       *Referred to as parameter k below.
       * </pre>
       */
      public Builder clearAlignerThreshold() {
        bitField0_ = (bitField0_ & ~0x00000001);
        alignerThreshold_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation> hits_ =
        java.util.Collections.emptyList();
      private void ensureHitsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          hits_ = new java.util.ArrayList<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation>(hits_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder> hitsBuilder_;

      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation> getHitsList() {
        if (hitsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(hits_);
        } else {
          return hitsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public int getHitsCount() {
        if (hitsBuilder_ == null) {
          return hits_.size();
        } else {
          return hitsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation getHits(int index) {
        if (hitsBuilder_ == null) {
          return hits_.get(index);
        } else {
          return hitsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder setHits(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation value) {
        if (hitsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHitsIsMutable();
          hits_.set(index, value);
          onChanged();
        } else {
          hitsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder setHits(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder builderForValue) {
        if (hitsBuilder_ == null) {
          ensureHitsIsMutable();
          hits_.set(index, builderForValue.build());
          onChanged();
        } else {
          hitsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder addHits(edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation value) {
        if (hitsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHitsIsMutable();
          hits_.add(value);
          onChanged();
        } else {
          hitsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder addHits(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation value) {
        if (hitsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHitsIsMutable();
          hits_.add(index, value);
          onChanged();
        } else {
          hitsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder addHits(
          edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder builderForValue) {
        if (hitsBuilder_ == null) {
          ensureHitsIsMutable();
          hits_.add(builderForValue.build());
          onChanged();
        } else {
          hitsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder addHits(
          int index, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder builderForValue) {
        if (hitsBuilder_ == null) {
          ensureHitsIsMutable();
          hits_.add(index, builderForValue.build());
          onChanged();
        } else {
          hitsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder addAllHits(
          java.lang.Iterable<? extends edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation> values) {
        if (hitsBuilder_ == null) {
          ensureHitsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, hits_);
          onChanged();
        } else {
          hitsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder clearHits() {
        if (hitsBuilder_ == null) {
          hits_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          hitsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public Builder removeHits(int index) {
        if (hitsBuilder_ == null) {
          ensureHitsIsMutable();
          hits_.remove(index);
          onChanged();
        } else {
          hitsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder getHitsBuilder(
          int index) {
        return getHitsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder getHitsOrBuilder(
          int index) {
        if (hitsBuilder_ == null) {
          return hits_.get(index);  } else {
          return hitsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public java.util.List<? extends edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder> 
           getHitsOrBuilderList() {
        if (hitsBuilder_ != null) {
          return hitsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(hits_);
        }
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder addHitsBuilder() {
        return getHitsFieldBuilder().addBuilder(
            edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder addHitsBuilder(
          int index) {
        return getHitsFieldBuilder().addBuilder(
            index, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.getDefaultInstance());
      }
      /**
       * <code>repeated .goby.AmbiguousLocation hits = 1;</code>
       *
       * <pre>
       *The hits that are assigned to several (&gt;k) reference location.
       * </pre>
       */
      public java.util.List<edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder> 
           getHitsBuilderList() {
        return getHitsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder> 
          getHitsFieldBuilder() {
        if (hitsBuilder_ == null) {
          hitsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder>(
                  hits_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          hits_ = null;
        }
        return hitsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:goby.AlignmentTooManyHits)
    }

    static {
      defaultInstance = new AlignmentTooManyHits(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.AlignmentTooManyHits)
  }

  public interface AmbiguousLocationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.AmbiguousLocation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required uint32 query_index = 1;</code>
     *
     * <pre>
     *The index of the query that matched too many times.
     * </pre>
     */
    boolean hasQueryIndex();
    /**
     * <code>required uint32 query_index = 1;</code>
     *
     * <pre>
     *The index of the query that matched too many times.
     * </pre>
     */
    int getQueryIndex();

    /**
     * <code>required uint32 at_least_number_of_hits = 2;</code>
     *
     * <pre>
     *The number of hits that triggered membership in the too many hits list. The query may hit more
     *locations than reported here, since some alignment tools will just drop queries that match above
     *a threshold and stop counting. This number can be &gt;=k.
     * </pre>
     */
    boolean hasAtLeastNumberOfHits();
    /**
     * <code>required uint32 at_least_number_of_hits = 2;</code>
     *
     * <pre>
     *The number of hits that triggered membership in the too many hits list. The query may hit more
     *locations than reported here, since some alignment tools will just drop queries that match above
     *a threshold and stop counting. This number can be &gt;=k.
     * </pre>
     */
    int getAtLeastNumberOfHits();

    /**
     * <code>optional uint32 length_of_match = 3;</code>
     *
     * <pre>
     **
     *The length of the part of the query sequence that could be matched to the target (also called depth).
     *May be less than the length of the query sequence, in which case the match was not perfect. When merging
     *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
     *from alignments that have exactly the longer depth for the query. 
     * </pre>
     */
    boolean hasLengthOfMatch();
    /**
     * <code>optional uint32 length_of_match = 3;</code>
     *
     * <pre>
     **
     *The length of the part of the query sequence that could be matched to the target (also called depth).
     *May be less than the length of the query sequence, in which case the match was not perfect. When merging
     *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
     *from alignments that have exactly the longer depth for the query. 
     * </pre>
     */
    int getLengthOfMatch();
  }
  /**
   * Protobuf type {@code goby.AmbiguousLocation}
   */
  public static final class AmbiguousLocation extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.AmbiguousLocation)
      AmbiguousLocationOrBuilder {
    // Use AmbiguousLocation.newBuilder() to construct.
    private AmbiguousLocation(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private AmbiguousLocation(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final AmbiguousLocation defaultInstance;
    public static AmbiguousLocation getDefaultInstance() {
      return defaultInstance;
    }

    public AmbiguousLocation getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private AmbiguousLocation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000001;
              queryIndex_ = input.readUInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              atLeastNumberOfHits_ = input.readUInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              lengthOfMatch_ = input.readUInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AmbiguousLocation_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AmbiguousLocation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.class, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder.class);
    }

    public static com.google.protobuf.Parser<AmbiguousLocation> PARSER =
        new com.google.protobuf.AbstractParser<AmbiguousLocation>() {
      public AmbiguousLocation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AmbiguousLocation(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<AmbiguousLocation> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int QUERY_INDEX_FIELD_NUMBER = 1;
    private int queryIndex_;
    /**
     * <code>required uint32 query_index = 1;</code>
     *
     * <pre>
     *The index of the query that matched too many times.
     * </pre>
     */
    public boolean hasQueryIndex() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required uint32 query_index = 1;</code>
     *
     * <pre>
     *The index of the query that matched too many times.
     * </pre>
     */
    public int getQueryIndex() {
      return queryIndex_;
    }

    public static final int AT_LEAST_NUMBER_OF_HITS_FIELD_NUMBER = 2;
    private int atLeastNumberOfHits_;
    /**
     * <code>required uint32 at_least_number_of_hits = 2;</code>
     *
     * <pre>
     *The number of hits that triggered membership in the too many hits list. The query may hit more
     *locations than reported here, since some alignment tools will just drop queries that match above
     *a threshold and stop counting. This number can be &gt;=k.
     * </pre>
     */
    public boolean hasAtLeastNumberOfHits() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required uint32 at_least_number_of_hits = 2;</code>
     *
     * <pre>
     *The number of hits that triggered membership in the too many hits list. The query may hit more
     *locations than reported here, since some alignment tools will just drop queries that match above
     *a threshold and stop counting. This number can be &gt;=k.
     * </pre>
     */
    public int getAtLeastNumberOfHits() {
      return atLeastNumberOfHits_;
    }

    public static final int LENGTH_OF_MATCH_FIELD_NUMBER = 3;
    private int lengthOfMatch_;
    /**
     * <code>optional uint32 length_of_match = 3;</code>
     *
     * <pre>
     **
     *The length of the part of the query sequence that could be matched to the target (also called depth).
     *May be less than the length of the query sequence, in which case the match was not perfect. When merging
     *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
     *from alignments that have exactly the longer depth for the query. 
     * </pre>
     */
    public boolean hasLengthOfMatch() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional uint32 length_of_match = 3;</code>
     *
     * <pre>
     **
     *The length of the part of the query sequence that could be matched to the target (also called depth).
     *May be less than the length of the query sequence, in which case the match was not perfect. When merging
     *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
     *from alignments that have exactly the longer depth for the query. 
     * </pre>
     */
    public int getLengthOfMatch() {
      return lengthOfMatch_;
    }

    private void initFields() {
      queryIndex_ = 0;
      atLeastNumberOfHits_ = 0;
      lengthOfMatch_ = 0;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasQueryIndex()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasAtLeastNumberOfHits()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt32(1, queryIndex_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt32(2, atLeastNumberOfHits_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt32(3, lengthOfMatch_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, queryIndex_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, atLeastNumberOfHits_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, lengthOfMatch_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.AmbiguousLocation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.AmbiguousLocation)
        edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AmbiguousLocation_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AmbiguousLocation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.class, edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        queryIndex_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        atLeastNumberOfHits_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        lengthOfMatch_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AmbiguousLocation_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation build() {
        edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation result = new edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.queryIndex_ = queryIndex_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.atLeastNumberOfHits_ = atLeastNumberOfHits_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.lengthOfMatch_ = lengthOfMatch_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation.getDefaultInstance()) return this;
        if (other.hasQueryIndex()) {
          setQueryIndex(other.getQueryIndex());
        }
        if (other.hasAtLeastNumberOfHits()) {
          setAtLeastNumberOfHits(other.getAtLeastNumberOfHits());
        }
        if (other.hasLengthOfMatch()) {
          setLengthOfMatch(other.getLengthOfMatch());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (!hasQueryIndex()) {
          
          return false;
        }
        if (!hasAtLeastNumberOfHits()) {
          
          return false;
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.AmbiguousLocation) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int queryIndex_ ;
      /**
       * <code>required uint32 query_index = 1;</code>
       *
       * <pre>
       *The index of the query that matched too many times.
       * </pre>
       */
      public boolean hasQueryIndex() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required uint32 query_index = 1;</code>
       *
       * <pre>
       *The index of the query that matched too many times.
       * </pre>
       */
      public int getQueryIndex() {
        return queryIndex_;
      }
      /**
       * <code>required uint32 query_index = 1;</code>
       *
       * <pre>
       *The index of the query that matched too many times.
       * </pre>
       */
      public Builder setQueryIndex(int value) {
        bitField0_ |= 0x00000001;
        queryIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required uint32 query_index = 1;</code>
       *
       * <pre>
       *The index of the query that matched too many times.
       * </pre>
       */
      public Builder clearQueryIndex() {
        bitField0_ = (bitField0_ & ~0x00000001);
        queryIndex_ = 0;
        onChanged();
        return this;
      }

      private int atLeastNumberOfHits_ ;
      /**
       * <code>required uint32 at_least_number_of_hits = 2;</code>
       *
       * <pre>
       *The number of hits that triggered membership in the too many hits list. The query may hit more
       *locations than reported here, since some alignment tools will just drop queries that match above
       *a threshold and stop counting. This number can be &gt;=k.
       * </pre>
       */
      public boolean hasAtLeastNumberOfHits() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>required uint32 at_least_number_of_hits = 2;</code>
       *
       * <pre>
       *The number of hits that triggered membership in the too many hits list. The query may hit more
       *locations than reported here, since some alignment tools will just drop queries that match above
       *a threshold and stop counting. This number can be &gt;=k.
       * </pre>
       */
      public int getAtLeastNumberOfHits() {
        return atLeastNumberOfHits_;
      }
      /**
       * <code>required uint32 at_least_number_of_hits = 2;</code>
       *
       * <pre>
       *The number of hits that triggered membership in the too many hits list. The query may hit more
       *locations than reported here, since some alignment tools will just drop queries that match above
       *a threshold and stop counting. This number can be &gt;=k.
       * </pre>
       */
      public Builder setAtLeastNumberOfHits(int value) {
        bitField0_ |= 0x00000002;
        atLeastNumberOfHits_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required uint32 at_least_number_of_hits = 2;</code>
       *
       * <pre>
       *The number of hits that triggered membership in the too many hits list. The query may hit more
       *locations than reported here, since some alignment tools will just drop queries that match above
       *a threshold and stop counting. This number can be &gt;=k.
       * </pre>
       */
      public Builder clearAtLeastNumberOfHits() {
        bitField0_ = (bitField0_ & ~0x00000002);
        atLeastNumberOfHits_ = 0;
        onChanged();
        return this;
      }

      private int lengthOfMatch_ ;
      /**
       * <code>optional uint32 length_of_match = 3;</code>
       *
       * <pre>
       **
       *The length of the part of the query sequence that could be matched to the target (also called depth).
       *May be less than the length of the query sequence, in which case the match was not perfect. When merging
       *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
       *from alignments that have exactly the longer depth for the query. 
       * </pre>
       */
      public boolean hasLengthOfMatch() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional uint32 length_of_match = 3;</code>
       *
       * <pre>
       **
       *The length of the part of the query sequence that could be matched to the target (also called depth).
       *May be less than the length of the query sequence, in which case the match was not perfect. When merging
       *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
       *from alignments that have exactly the longer depth for the query. 
       * </pre>
       */
      public int getLengthOfMatch() {
        return lengthOfMatch_;
      }
      /**
       * <code>optional uint32 length_of_match = 3;</code>
       *
       * <pre>
       **
       *The length of the part of the query sequence that could be matched to the target (also called depth).
       *May be less than the length of the query sequence, in which case the match was not perfect. When merging
       *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
       *from alignments that have exactly the longer depth for the query. 
       * </pre>
       */
      public Builder setLengthOfMatch(int value) {
        bitField0_ |= 0x00000004;
        lengthOfMatch_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 length_of_match = 3;</code>
       *
       * <pre>
       **
       *The length of the part of the query sequence that could be matched to the target (also called depth).
       *May be less than the length of the query sequence, in which case the match was not perfect. When merging
       *alignments produced by searching different reference sequences, consider only at_least_number_of_hits
       *from alignments that have exactly the longer depth for the query. 
       * </pre>
       */
      public Builder clearLengthOfMatch() {
        bitField0_ = (bitField0_ & ~0x00000004);
        lengthOfMatch_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:goby.AmbiguousLocation)
    }

    static {
      defaultInstance = new AmbiguousLocation(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.AmbiguousLocation)
  }

  public interface AlignmentIndexOrBuilder extends
      // @@protoc_insertion_point(interface_extends:goby.AlignmentIndex)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
     *
     * <pre>
     *Stores one element by target sequence. Each element is the cumulative target length for the target
     *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
     *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
     *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
     *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
     * </pre>
     */
    java.util.List<java.lang.Integer> getTargetPositionOffsetsList();
    /**
     * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
     *
     * <pre>
     *Stores one element by target sequence. Each element is the cumulative target length for the target
     *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
     *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
     *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
     *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
     * </pre>
     */
    int getTargetPositionOffsetsCount();
    /**
     * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
     *
     * <pre>
     *Stores one element by target sequence. Each element is the cumulative target length for the target
     *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
     *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
     *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
     *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
     * </pre>
     */
    int getTargetPositionOffsets(int index);

    /**
     * <code>repeated uint64 offsets = 2 [packed = true];</code>
     *
     * <pre>
     *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
     *by index. There should be as many elements in offsets as there are in absolutePosition
     *where chunks start which represent entries whose absolute positions are less than
     * </pre>
     */
    java.util.List<java.lang.Long> getOffsetsList();
    /**
     * <code>repeated uint64 offsets = 2 [packed = true];</code>
     *
     * <pre>
     *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
     *by index. There should be as many elements in offsets as there are in absolutePosition
     *where chunks start which represent entries whose absolute positions are less than
     * </pre>
     */
    int getOffsetsCount();
    /**
     * <code>repeated uint64 offsets = 2 [packed = true];</code>
     *
     * <pre>
     *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
     *by index. There should be as many elements in offsets as there are in absolutePosition
     *where chunks start which represent entries whose absolute positions are less than
     * </pre>
     */
    long getOffsets(int index);

    /**
     * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
     *
     * <pre>
     *The absolute positions of the first entry in the chunk that immediately start at offset. One element
     *per chunk in the 'basename'.entries file.
     * </pre>
     */
    java.util.List<java.lang.Long> getAbsolutePositionsList();
    /**
     * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
     *
     * <pre>
     *The absolute positions of the first entry in the chunk that immediately start at offset. One element
     *per chunk in the 'basename'.entries file.
     * </pre>
     */
    int getAbsolutePositionsCount();
    /**
     * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
     *
     * <pre>
     *The absolute positions of the first entry in the chunk that immediately start at offset. One element
     *per chunk in the 'basename'.entries file.
     * </pre>
     */
    long getAbsolutePositions(int index);
  }
  /**
   * Protobuf type {@code goby.AlignmentIndex}
   *
   * <pre>
   *This message is written to 'basename'.index
   * </pre>
   */
  public static final class AlignmentIndex extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:goby.AlignmentIndex)
      AlignmentIndexOrBuilder {
    // Use AlignmentIndex.newBuilder() to construct.
    private AlignmentIndex(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private AlignmentIndex(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final AlignmentIndex defaultInstance;
    public static AlignmentIndex getDefaultInstance() {
      return defaultInstance;
    }

    public AlignmentIndex getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private AlignmentIndex(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                targetPositionOffsets_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000001;
              }
              targetPositionOffsets_.add(input.readUInt32());
              break;
            }
            case 10: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001) && input.getBytesUntilLimit() > 0) {
                targetPositionOffsets_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000001;
              }
              while (input.getBytesUntilLimit() > 0) {
                targetPositionOffsets_.add(input.readUInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 16: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                offsets_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000002;
              }
              offsets_.add(input.readUInt64());
              break;
            }
            case 18: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002) && input.getBytesUntilLimit() > 0) {
                offsets_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000002;
              }
              while (input.getBytesUntilLimit() > 0) {
                offsets_.add(input.readUInt64());
              }
              input.popLimit(limit);
              break;
            }
            case 24: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                absolutePositions_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000004;
              }
              absolutePositions_.add(input.readUInt64());
              break;
            }
            case 26: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004) && input.getBytesUntilLimit() > 0) {
                absolutePositions_ = new java.util.ArrayList<java.lang.Long>();
                mutable_bitField0_ |= 0x00000004;
              }
              while (input.getBytesUntilLimit() > 0) {
                absolutePositions_.add(input.readUInt64());
              }
              input.popLimit(limit);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          targetPositionOffsets_ = java.util.Collections.unmodifiableList(targetPositionOffsets_);
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          offsets_ = java.util.Collections.unmodifiableList(offsets_);
        }
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          absolutePositions_ = java.util.Collections.unmodifiableList(absolutePositions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentIndex_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentIndex_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex.Builder.class);
    }

    public static com.google.protobuf.Parser<AlignmentIndex> PARSER =
        new com.google.protobuf.AbstractParser<AlignmentIndex>() {
      public AlignmentIndex parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AlignmentIndex(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<AlignmentIndex> getParserForType() {
      return PARSER;
    }

    public static final int TARGET_POSITION_OFFSETS_FIELD_NUMBER = 1;
    private java.util.List<java.lang.Integer> targetPositionOffsets_;
    /**
     * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
     *
     * <pre>
     *Stores one element by target sequence. Each element is the cumulative target length for the target
     *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
     *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
     *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
     *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
     * </pre>
     */
    public java.util.List<java.lang.Integer>
        getTargetPositionOffsetsList() {
      return targetPositionOffsets_;
    }
    /**
     * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
     *
     * <pre>
     *Stores one element by target sequence. Each element is the cumulative target length for the target
     *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
     *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
     *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
     *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
     * </pre>
     */
    public int getTargetPositionOffsetsCount() {
      return targetPositionOffsets_.size();
    }
    /**
     * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
     *
     * <pre>
     *Stores one element by target sequence. Each element is the cumulative target length for the target
     *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
     *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
     *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
     *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
     * </pre>
     */
    public int getTargetPositionOffsets(int index) {
      return targetPositionOffsets_.get(index);
    }
    private int targetPositionOffsetsMemoizedSerializedSize = -1;

    public static final int OFFSETS_FIELD_NUMBER = 2;
    private java.util.List<java.lang.Long> offsets_;
    /**
     * <code>repeated uint64 offsets = 2 [packed = true];</code>
     *
     * <pre>
     *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
     *by index. There should be as many elements in offsets as there are in absolutePosition
     *where chunks start which represent entries whose absolute positions are less than
     * </pre>
     */
    public java.util.List<java.lang.Long>
        getOffsetsList() {
      return offsets_;
    }
    /**
     * <code>repeated uint64 offsets = 2 [packed = true];</code>
     *
     * <pre>
     *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
     *by index. There should be as many elements in offsets as there are in absolutePosition
     *where chunks start which represent entries whose absolute positions are less than
     * </pre>
     */
    public int getOffsetsCount() {
      return offsets_.size();
    }
    /**
     * <code>repeated uint64 offsets = 2 [packed = true];</code>
     *
     * <pre>
     *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
     *by index. There should be as many elements in offsets as there are in absolutePosition
     *where chunks start which represent entries whose absolute positions are less than
     * </pre>
     */
    public long getOffsets(int index) {
      return offsets_.get(index);
    }
    private int offsetsMemoizedSerializedSize = -1;

    public static final int ABSOLUTE_POSITIONS_FIELD_NUMBER = 3;
    private java.util.List<java.lang.Long> absolutePositions_;
    /**
     * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
     *
     * <pre>
     *The absolute positions of the first entry in the chunk that immediately start at offset. One element
     *per chunk in the 'basename'.entries file.
     * </pre>
     */
    public java.util.List<java.lang.Long>
        getAbsolutePositionsList() {
      return absolutePositions_;
    }
    /**
     * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
     *
     * <pre>
     *The absolute positions of the first entry in the chunk that immediately start at offset. One element
     *per chunk in the 'basename'.entries file.
     * </pre>
     */
    public int getAbsolutePositionsCount() {
      return absolutePositions_.size();
    }
    /**
     * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
     *
     * <pre>
     *The absolute positions of the first entry in the chunk that immediately start at offset. One element
     *per chunk in the 'basename'.entries file.
     * </pre>
     */
    public long getAbsolutePositions(int index) {
      return absolutePositions_.get(index);
    }
    private int absolutePositionsMemoizedSerializedSize = -1;

    private void initFields() {
      targetPositionOffsets_ = java.util.Collections.emptyList();
      offsets_ = java.util.Collections.emptyList();
      absolutePositions_ = java.util.Collections.emptyList();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (getTargetPositionOffsetsList().size() > 0) {
        output.writeRawVarint32(10);
        output.writeRawVarint32(targetPositionOffsetsMemoizedSerializedSize);
      }
      for (int i = 0; i < targetPositionOffsets_.size(); i++) {
        output.writeUInt32NoTag(targetPositionOffsets_.get(i));
      }
      if (getOffsetsList().size() > 0) {
        output.writeRawVarint32(18);
        output.writeRawVarint32(offsetsMemoizedSerializedSize);
      }
      for (int i = 0; i < offsets_.size(); i++) {
        output.writeUInt64NoTag(offsets_.get(i));
      }
      if (getAbsolutePositionsList().size() > 0) {
        output.writeRawVarint32(26);
        output.writeRawVarint32(absolutePositionsMemoizedSerializedSize);
      }
      for (int i = 0; i < absolutePositions_.size(); i++) {
        output.writeUInt64NoTag(absolutePositions_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < targetPositionOffsets_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(targetPositionOffsets_.get(i));
        }
        size += dataSize;
        if (!getTargetPositionOffsetsList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        targetPositionOffsetsMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < offsets_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt64SizeNoTag(offsets_.get(i));
        }
        size += dataSize;
        if (!getOffsetsList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        offsetsMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < absolutePositions_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt64SizeNoTag(absolutePositions_.get(i));
        }
        size += dataSize;
        if (!getAbsolutePositionsList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        absolutePositionsMemoizedSerializedSize = dataSize;
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code goby.AlignmentIndex}
     *
     * <pre>
     *This message is written to 'basename'.index
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:goby.AlignmentIndex)
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndexOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentIndex_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentIndex_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex.class, edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex.Builder.class);
      }

      // Construct using edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        targetPositionOffsets_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        offsets_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        absolutePositions_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.internal_static_goby_AlignmentIndex_descriptor;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex getDefaultInstanceForType() {
        return edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex.getDefaultInstance();
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex build() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex buildPartial() {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex result = new edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex(this);
        int from_bitField0_ = bitField0_;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          targetPositionOffsets_ = java.util.Collections.unmodifiableList(targetPositionOffsets_);
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.targetPositionOffsets_ = targetPositionOffsets_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          offsets_ = java.util.Collections.unmodifiableList(offsets_);
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.offsets_ = offsets_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          absolutePositions_ = java.util.Collections.unmodifiableList(absolutePositions_);
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.absolutePositions_ = absolutePositions_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex) {
          return mergeFrom((edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex other) {
        if (other == edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex.getDefaultInstance()) return this;
        if (!other.targetPositionOffsets_.isEmpty()) {
          if (targetPositionOffsets_.isEmpty()) {
            targetPositionOffsets_ = other.targetPositionOffsets_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureTargetPositionOffsetsIsMutable();
            targetPositionOffsets_.addAll(other.targetPositionOffsets_);
          }
          onChanged();
        }
        if (!other.offsets_.isEmpty()) {
          if (offsets_.isEmpty()) {
            offsets_ = other.offsets_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureOffsetsIsMutable();
            offsets_.addAll(other.offsets_);
          }
          onChanged();
        }
        if (!other.absolutePositions_.isEmpty()) {
          if (absolutePositions_.isEmpty()) {
            absolutePositions_ = other.absolutePositions_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureAbsolutePositionsIsMutable();
            absolutePositions_.addAll(other.absolutePositions_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (edu.cornell.med.icb.goby.alignments.Alignments.AlignmentIndex) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<java.lang.Integer> targetPositionOffsets_ = java.util.Collections.emptyList();
      private void ensureTargetPositionOffsetsIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          targetPositionOffsets_ = new java.util.ArrayList<java.lang.Integer>(targetPositionOffsets_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
       *
       * <pre>
       *Stores one element by target sequence. Each element is the cumulative target length for the target
       *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
       *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
       *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
       *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
       * </pre>
       */
      public java.util.List<java.lang.Integer>
          getTargetPositionOffsetsList() {
        return java.util.Collections.unmodifiableList(targetPositionOffsets_);
      }
      /**
       * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
       *
       * <pre>
       *Stores one element by target sequence. Each element is the cumulative target length for the target
       *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
       *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
       *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
       *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
       * </pre>
       */
      public int getTargetPositionOffsetsCount() {
        return targetPositionOffsets_.size();
      }
      /**
       * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
       *
       * <pre>
       *Stores one element by target sequence. Each element is the cumulative target length for the target
       *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
       *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
       *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
       *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
       * </pre>
       */
      public int getTargetPositionOffsets(int index) {
        return targetPositionOffsets_.get(index);
      }
      /**
       * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
       *
       * <pre>
       *Stores one element by target sequence. Each element is the cumulative target length for the target
       *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
       *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
       *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
       *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
       * </pre>
       */
      public Builder setTargetPositionOffsets(
          int index, int value) {
        ensureTargetPositionOffsetsIsMutable();
        targetPositionOffsets_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
       *
       * <pre>
       *Stores one element by target sequence. Each element is the cumulative target length for the target
       *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
       *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
       *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
       *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
       * </pre>
       */
      public Builder addTargetPositionOffsets(int value) {
        ensureTargetPositionOffsetsIsMutable();
        targetPositionOffsets_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
       *
       * <pre>
       *Stores one element by target sequence. Each element is the cumulative target length for the target
       *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
       *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
       *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
       *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
       * </pre>
       */
      public Builder addAllTargetPositionOffsets(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureTargetPositionOffsetsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, targetPositionOffsets_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint32 target_position_offsets = 1 [packed = true];</code>
       *
       * <pre>
       *Stores one element by target sequence. Each element is the cumulative target length for the target
       *stored at index i. Assume there are four target sequences, with lengths {10, 12, 15, 34}. The field
       *targetPositionOffsets will contain: {0,10,22,37}. Such offsets can be used to calculate the absolute
       *position of a genomic location. Given targetIndex and positionOnReference, the absolute location
       *is defined as  targetPositionOffsets[targetIndex]+positionOnReference.
       * </pre>
       */
      public Builder clearTargetPositionOffsets() {
        targetPositionOffsets_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Long> offsets_ = java.util.Collections.emptyList();
      private void ensureOffsetsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          offsets_ = new java.util.ArrayList<java.lang.Long>(offsets_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <code>repeated uint64 offsets = 2 [packed = true];</code>
       *
       * <pre>
       *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
       *by index. There should be as many elements in offsets as there are in absolutePosition
       *where chunks start which represent entries whose absolute positions are less than
       * </pre>
       */
      public java.util.List<java.lang.Long>
          getOffsetsList() {
        return java.util.Collections.unmodifiableList(offsets_);
      }
      /**
       * <code>repeated uint64 offsets = 2 [packed = true];</code>
       *
       * <pre>
       *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
       *by index. There should be as many elements in offsets as there are in absolutePosition
       *where chunks start which represent entries whose absolute positions are less than
       * </pre>
       */
      public int getOffsetsCount() {
        return offsets_.size();
      }
      /**
       * <code>repeated uint64 offsets = 2 [packed = true];</code>
       *
       * <pre>
       *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
       *by index. There should be as many elements in offsets as there are in absolutePosition
       *where chunks start which represent entries whose absolute positions are less than
       * </pre>
       */
      public long getOffsets(int index) {
        return offsets_.get(index);
      }
      /**
       * <code>repeated uint64 offsets = 2 [packed = true];</code>
       *
       * <pre>
       *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
       *by index. There should be as many elements in offsets as there are in absolutePosition
       *where chunks start which represent entries whose absolute positions are less than
       * </pre>
       */
      public Builder setOffsets(
          int index, long value) {
        ensureOffsetsIsMutable();
        offsets_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint64 offsets = 2 [packed = true];</code>
       *
       * <pre>
       *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
       *by index. There should be as many elements in offsets as there are in absolutePosition
       *where chunks start which represent entries whose absolute positions are less than
       * </pre>
       */
      public Builder addOffsets(long value) {
        ensureOffsetsIsMutable();
        offsets_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint64 offsets = 2 [packed = true];</code>
       *
       * <pre>
       *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
       *by index. There should be as many elements in offsets as there are in absolutePosition
       *where chunks start which represent entries whose absolute positions are less than
       * </pre>
       */
      public Builder addAllOffsets(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureOffsetsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, offsets_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint64 offsets = 2 [packed = true];</code>
       *
       * <pre>
       *The byte offsets into the compressed entries file. Byte offsets are matched with absolute position
       *by index. There should be as many elements in offsets as there are in absolutePosition
       *where chunks start which represent entries whose absolute positions are less than
       * </pre>
       */
      public Builder clearOffsets() {
        offsets_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Long> absolutePositions_ = java.util.Collections.emptyList();
      private void ensureAbsolutePositionsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          absolutePositions_ = new java.util.ArrayList<java.lang.Long>(absolutePositions_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
       *
       * <pre>
       *The absolute positions of the first entry in the chunk that immediately start at offset. One element
       *per chunk in the 'basename'.entries file.
       * </pre>
       */
      public java.util.List<java.lang.Long>
          getAbsolutePositionsList() {
        return java.util.Collections.unmodifiableList(absolutePositions_);
      }
      /**
       * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
       *
       * <pre>
       *The absolute positions of the first entry in the chunk that immediately start at offset. One element
       *per chunk in the 'basename'.entries file.
       * </pre>
       */
      public int getAbsolutePositionsCount() {
        return absolutePositions_.size();
      }
      /**
       * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
       *
       * <pre>
       *The absolute positions of the first entry in the chunk that immediately start at offset. One element
       *per chunk in the 'basename'.entries file.
       * </pre>
       */
      public long getAbsolutePositions(int index) {
        return absolutePositions_.get(index);
      }
      /**
       * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
       *
       * <pre>
       *The absolute positions of the first entry in the chunk that immediately start at offset. One element
       *per chunk in the 'basename'.entries file.
       * </pre>
       */
      public Builder setAbsolutePositions(
          int index, long value) {
        ensureAbsolutePositionsIsMutable();
        absolutePositions_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
       *
       * <pre>
       *The absolute positions of the first entry in the chunk that immediately start at offset. One element
       *per chunk in the 'basename'.entries file.
       * </pre>
       */
      public Builder addAbsolutePositions(long value) {
        ensureAbsolutePositionsIsMutable();
        absolutePositions_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
       *
       * <pre>
       *The absolute positions of the first entry in the chunk that immediately start at offset. One element
       *per chunk in the 'basename'.entries file.
       * </pre>
       */
      public Builder addAllAbsolutePositions(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureAbsolutePositionsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, absolutePositions_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated uint64 absolute_positions = 3 [packed = true];</code>
       *
       * <pre>
       *The absolute positions of the first entry in the chunk that immediately start at offset. One element
       *per chunk in the 'basename'.entries file.
       * </pre>
       */
      public Builder clearAbsolutePositions() {
        absolutePositions_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:goby.AlignmentIndex)
    }

    static {
      defaultInstance = new AlignmentIndex(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:goby.AlignmentIndex)
  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_AlignmentCollection_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_AlignmentCollection_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_AlignmentEntry_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_AlignmentEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_RelatedAlignmentEntry_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_RelatedAlignmentEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_SequenceVariation_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_SequenceVariation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_AlignmentHeader_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_AlignmentHeader_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_IdentifierMapping_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_IdentifierMapping_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_IdentifierInfo_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_IdentifierInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_ReadOriginInfo_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_ReadOriginInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_AlignmentTooManyHits_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_AlignmentTooManyHits_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_AmbiguousLocation_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_AmbiguousLocation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_goby_AlignmentIndex_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_goby_AlignmentIndex_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\020Alignments.proto\022\004goby\"F\n\023AlignmentCol" +
      "lection\022/\n\021alignment_entries\030\001 \003(\0132\024.gob" +
      "y.AlignmentEntry\"\213\010\n\016AlignmentEntry\022\024\n\014m" +
      "ultiplicity\030\007 \001(\r\022\023\n\013query_index\030\001 \001(\r\022\024" +
      "\n\014target_index\030\002 \001(\r\022\020\n\010position\030\003 \001(\r\022\037" +
      "\n\027matching_reverse_strand\030\006 \001(\010\022\026\n\016query" +
      "_position\030\005 \001(\r\022\r\n\005score\030\004 \001(\002\022\034\n\024number" +
      "_of_mismatches\030\010 \001(\r\022\030\n\020number_of_indels" +
      "\030\t \001(\r\022\034\n\024query_aligned_length\030\013 \001(\r\022\035\n\025" +
      "target_aligned_length\030\014 \001(\r\0224\n\023sequence_",
      "variations\030\r \003(\0132\027.goby.SequenceVariatio" +
      "n\022\024\n\014query_length\030\n \001(\r\022\027\n\017mapping_quali" +
      "ty\030\016 \001(\005\022\022\n\npair_flags\030\017 \001(\r\0228\n\023pair_ali" +
      "gnment_link\030\020 \001(\0132\033.goby.RelatedAlignmen" +
      "tEntry\022\026\n\016fragment_index\030\021 \001(\r\022C\n\036splice" +
      "d_forward_alignment_link\030\022 \001(\0132\033.goby.Re" +
      "latedAlignmentEntry\022D\n\037spliced_backward_" +
      "alignment_link\030\026 \001(\0132\033.goby.RelatedAlign" +
      "mentEntry\022\025\n\rspliced_flags\030\023 \001(\r\022\023\n\013inse" +
      "rt_size\030\024 \001(\021\022\024\n\014sample_index\030\025 \001(\r\022\037\n\027q",
      "uery_index_occurrences\030\031 \001(\r\022\021\n\tambiguit" +
      "y\030\033 \001(\r\022\026\n\016bam_attributes\0302 \003(\t\022\033\n\023read_" +
      "quality_scores\0307 \001(\014\022\031\n\021read_origin_inde" +
      "x\030\032 \001(\r\022\034\n\024softClippedBasesLeft\030\036 \001(\t\022\035\n" +
      "\025softClippedBasesRight\030\037 \001(\t\022\036\n\026softClip" +
      "pedQualityLeft\030  \001(\014\022\037\n\027softClippedQuali" +
      "tyRight\030! \001(\014\022\036\n\026placedUnmappedSequence\030" +
      "( \001(\t\022\035\n\025placedUnmappedQuality\030) \001(\014\022\020\n\010" +
      "readName\030* \001(\t\"p\n\025RelatedAlignmentEntry\022" +
      "\024\n\014target_index\030\001 \001(\r\022\020\n\010position\030\002 \001(\r\022",
      "\026\n\016fragment_index\030\003 \001(\r\022\027\n\017optimized_ind" +
      "ex\0302 \001(\r\"g\n\021SequenceVariation\022\014\n\004from\030\002 " +
      "\001(\t\022\n\n\002to\030\001 \001(\t\022\020\n\010position\030\003 \001(\r\022\022\n\nrea" +
      "d_index\030\005 \001(\r\022\022\n\nto_quality\030\004 \001(\014\"\304\005\n\017Al" +
      "ignmentHeader\022\"\n\032smallest_split_query_in" +
      "dex\030\t \001(\r\022!\n\031largest_split_query_index\030\013" +
      " \001(\r\0223\n\022query_name_mapping\030\001 \001(\0132\027.goby." +
      "IdentifierMapping\0224\n\023target_name_mapping" +
      "\030\002 \001(\0132\027.goby.IdentifierMapping\022\031\n\021numbe" +
      "r_of_queries\030\005 \001(\r\022\031\n\021number_of_targets\030",
      "\006 \001(\r\022\037\n\027number_of_aligned_reads\030\007 \001(\r\022\030" +
      "\n\014query_length\030\003 \003(\rB\002\030\001\022\035\n\025constant_que" +
      "ry_length\030\n \001(\r\022\025\n\rtarget_length\030\010 \003(\r\022\016" +
      "\n\006sorted\030\r \001(\010\022\017\n\007indexed\030\016 \001(\010\022\'\n\037query" +
      "_lengths_stored_in_entries\030\017 \001(\010\022\024\n\014alig" +
      "ner_name\030\021 \001(\t\022\027\n\017aligner_version\030\022 \001(\t\022" +
      "\017\n\007version\030\031 \001(\t\022\027\n\017sample_basename\030\036 \003(" +
      "\t\022#\n\033query_indices_were_permuted\030\032 \001(\010\022\037" +
      "\n\027query_index_occurrences\030# \001(\010\022#\n\033ambig" +
      "uity_stored_in_entries\030$ \001(\010\022\037\n\027all_read",
      "_quality_scores\030( \001(\010\022)\n\013read_origin\030\033 \003" +
      "(\0132\024.goby.ReadOriginInfo\";\n\021IdentifierMa" +
      "pping\022&\n\010mappings\030\001 \003(\0132\024.goby.Identifie" +
      "rInfo\"-\n\016IdentifierInfo\022\014\n\004name\030\001 \002(\t\022\r\n" +
      "\005index\030\002 \002(\r\"\225\001\n\016ReadOriginInfo\022\024\n\014origi" +
      "n_index\030\001 \002(\r\022\021\n\torigin_id\030\002 \002(\t\022\016\n\006samp" +
      "le\030\004 \001(\t\022\020\n\010platform\030\005 \001(\t\022\017\n\007library\030\010 " +
      "\001(\t\022\025\n\rplatform_unit\030\014 \001(\t\022\020\n\010run_date\030\006" +
      " \001(\t\"X\n\024AlignmentTooManyHits\022\031\n\021aligner_" +
      "threshold\030\002 \002(\r\022%\n\004hits\030\001 \003(\0132\027.goby.Amb",
      "iguousLocation\"b\n\021AmbiguousLocation\022\023\n\013q" +
      "uery_index\030\001 \002(\r\022\037\n\027at_least_number_of_h" +
      "its\030\002 \002(\r\022\027\n\017length_of_match\030\003 \001(\r\"j\n\016Al" +
      "ignmentIndex\022#\n\027target_position_offsets\030" +
      "\001 \003(\rB\002\020\001\022\023\n\007offsets\030\002 \003(\004B\002\020\001\022\036\n\022absolu" +
      "te_positions\030\003 \003(\004B\002\020\001B\'\n#edu.cornell.me" +
      "d.icb.goby.alignmentsH\001"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
    internal_static_goby_AlignmentCollection_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_goby_AlignmentCollection_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_AlignmentCollection_descriptor,
        new java.lang.String[] { "AlignmentEntries", });
    internal_static_goby_AlignmentEntry_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_goby_AlignmentEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_AlignmentEntry_descriptor,
        new java.lang.String[] { "Multiplicity", "QueryIndex", "TargetIndex", "Position", "MatchingReverseStrand", "QueryPosition", "Score", "NumberOfMismatches", "NumberOfIndels", "QueryAlignedLength", "TargetAlignedLength", "SequenceVariations", "QueryLength", "MappingQuality", "PairFlags", "PairAlignmentLink", "FragmentIndex", "SplicedForwardAlignmentLink", "SplicedBackwardAlignmentLink", "SplicedFlags", "InsertSize", "SampleIndex", "QueryIndexOccurrences", "Ambiguity", "BamAttributes", "ReadQualityScores", "ReadOriginIndex", "SoftClippedBasesLeft", "SoftClippedBasesRight", "SoftClippedQualityLeft", "SoftClippedQualityRight", "PlacedUnmappedSequence", "PlacedUnmappedQuality", "ReadName", });
    internal_static_goby_RelatedAlignmentEntry_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_goby_RelatedAlignmentEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_RelatedAlignmentEntry_descriptor,
        new java.lang.String[] { "TargetIndex", "Position", "FragmentIndex", "OptimizedIndex", });
    internal_static_goby_SequenceVariation_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_goby_SequenceVariation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_SequenceVariation_descriptor,
        new java.lang.String[] { "From", "To", "Position", "ReadIndex", "ToQuality", });
    internal_static_goby_AlignmentHeader_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_goby_AlignmentHeader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_AlignmentHeader_descriptor,
        new java.lang.String[] { "SmallestSplitQueryIndex", "LargestSplitQueryIndex", "QueryNameMapping", "TargetNameMapping", "NumberOfQueries", "NumberOfTargets", "NumberOfAlignedReads", "QueryLength", "ConstantQueryLength", "TargetLength", "Sorted", "Indexed", "QueryLengthsStoredInEntries", "AlignerName", "AlignerVersion", "Version", "SampleBasename", "QueryIndicesWerePermuted", "QueryIndexOccurrences", "AmbiguityStoredInEntries", "AllReadQualityScores", "ReadOrigin", });
    internal_static_goby_IdentifierMapping_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_goby_IdentifierMapping_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_IdentifierMapping_descriptor,
        new java.lang.String[] { "Mappings", });
    internal_static_goby_IdentifierInfo_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_goby_IdentifierInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_IdentifierInfo_descriptor,
        new java.lang.String[] { "Name", "Index", });
    internal_static_goby_ReadOriginInfo_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_goby_ReadOriginInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_ReadOriginInfo_descriptor,
        new java.lang.String[] { "OriginIndex", "OriginId", "Sample", "Platform", "Library", "PlatformUnit", "RunDate", });
    internal_static_goby_AlignmentTooManyHits_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_goby_AlignmentTooManyHits_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_AlignmentTooManyHits_descriptor,
        new java.lang.String[] { "AlignerThreshold", "Hits", });
    internal_static_goby_AmbiguousLocation_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_goby_AmbiguousLocation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_AmbiguousLocation_descriptor,
        new java.lang.String[] { "QueryIndex", "AtLeastNumberOfHits", "LengthOfMatch", });
    internal_static_goby_AlignmentIndex_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_goby_AlignmentIndex_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_goby_AlignmentIndex_descriptor,
        new java.lang.String[] { "TargetPositionOffsets", "Offsets", "AbsolutePositions", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
